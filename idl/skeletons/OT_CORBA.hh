// This file is generated by omniidl (C++ backend)- omniORB_4_0. Do not edit.
#ifndef __OT__CORBA_hh__
#define __OT__CORBA_hh__

#ifndef USE_omniORB_logStream
#define USE_omniORB_logStream
#endif

#ifndef __CORBA_H_EXTERNAL_GUARD__
#include <omniORB4/CORBA.h>
#endif

#ifndef  USE_core_stub_in_nt_dll
# define USE_core_stub_in_nt_dll_NOT_DEFINED_OT__CORBA
#endif
#ifndef  USE_dyn_stub_in_nt_dll
# define USE_dyn_stub_in_nt_dll_NOT_DEFINED_OT__CORBA
#endif






#ifdef USE_stub_in_nt_dll
#ifndef USE_core_stub_in_nt_dll
#define USE_core_stub_in_nt_dll
#endif
#ifndef USE_dyn_stub_in_nt_dll
#define USE_dyn_stub_in_nt_dll
#endif
#endif

#ifdef _core_attr
# error "A local CPP macro _core_attr has already been defined."
#else
# ifdef  USE_core_stub_in_nt_dll
#  define _core_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _core_attr
# endif
#endif

#ifdef _dyn_attr
# error "A local CPP macro _dyn_attr has already been defined."
#else
# ifdef  USE_dyn_stub_in_nt_dll
#  define _dyn_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _dyn_attr
# endif
#endif





_CORBA_MODULE CORBAModule

_CORBA_MODULE_BEG

  _CORBA_MODULE_VAR _core_attr const char * CORBAModule__doc__;

  typedef CORBA::Float Position[3];
  typedef CORBA::Float Position_slice;

  _CORBA_MODULE_INLINE Position_slice* Position_alloc() {
    return new Position_slice[3];
  }

  _CORBA_MODULE_INLINE Position_slice* Position_dup(const Position_slice* _s) {
    if (!_s) return 0;
    Position_slice* _data = Position_alloc();
    if (_data) {
      for (CORBA::ULong _i0 = 0;_i0 < 3;_i0++){
        
        _data[_i0] = _s[_i0];

      }
  
    }
    return _data;
  }

  _CORBA_MODULE_INLINE void Position_copy(Position_slice* _to, const Position_slice* _from){
    for (CORBA::ULong _i0 = 0;_i0 < 3;_i0++){
      
      _to[_i0] = _from[_i0];

    }
  
  }

  _CORBA_MODULE_INLINE void Position_free(Position_slice* _s) {
      delete [] _s;
  }

  class Position_copyHelper {
  public:
    static inline Position_slice* alloc() { return Position_alloc(); }
    static inline Position_slice* dup(const Position_slice* p) { return Position_dup(p); }
    static inline void free(Position_slice* p) { Position_free(p); }
  };

  typedef _CORBA_Array_Fix_Var<Position_copyHelper,Position_slice> Position_var;
  typedef _CORBA_Array_Fix_Forany<Position_copyHelper,Position_slice> Position_forany;

  typedef Position_slice* Position_out;

  typedef CORBA::Float Orientation[4];
  typedef CORBA::Float Orientation_slice;

  _CORBA_MODULE_INLINE Orientation_slice* Orientation_alloc() {
    return new Orientation_slice[4];
  }

  _CORBA_MODULE_INLINE Orientation_slice* Orientation_dup(const Orientation_slice* _s) {
    if (!_s) return 0;
    Orientation_slice* _data = Orientation_alloc();
    if (_data) {
      for (CORBA::ULong _i0 = 0;_i0 < 4;_i0++){
        
        _data[_i0] = _s[_i0];

      }
  
    }
    return _data;
  }

  _CORBA_MODULE_INLINE void Orientation_copy(Orientation_slice* _to, const Orientation_slice* _from){
    for (CORBA::ULong _i0 = 0;_i0 < 4;_i0++){
      
      _to[_i0] = _from[_i0];

    }
  
  }

  _CORBA_MODULE_INLINE void Orientation_free(Orientation_slice* _s) {
      delete [] _s;
  }

  class Orientation_copyHelper {
  public:
    static inline Orientation_slice* alloc() { return Orientation_alloc(); }
    static inline Orientation_slice* dup(const Orientation_slice* p) { return Orientation_dup(p); }
    static inline void free(Orientation_slice* p) { Orientation_free(p); }
  };

  typedef _CORBA_Array_Fix_Var<Orientation_copyHelper,Orientation_slice> Orientation_var;
  typedef _CORBA_Array_Fix_Forany<Orientation_copyHelper,Orientation_slice> Orientation_forany;

  typedef Orientation_slice* Orientation_out;

  typedef CORBA::Float Timestamp;
  typedef CORBA::Float_out Timestamp_out;

  typedef CORBA::Short Button;
  typedef CORBA::Short_out Button_out;

  typedef CORBA::Float Confidence;
  typedef CORBA::Float_out Confidence_out;

#ifndef __CORBAModule_mEvent__
#define __CORBAModule_mEvent__

  class Event;
  class _objref_Event;
  class _impl_Event;
  
  typedef _objref_Event* Event_ptr;
  typedef Event_ptr EventRef;

  class Event_Helper {
  public:
    typedef Event_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_Event, Event_Helper> Event_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_Event,Event_Helper > Event_out;

#endif

  class Event {
  public:
    // Declarations for this interface type.
    typedef Event_ptr _ptr_type;
    typedef Event_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(CORBA::Object_ptr);
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_Event :
    public virtual CORBA::Object, public virtual omniObjRef
  {
  public:
    CORBA::Boolean hasAttribute(const char* name);
    CORBA::Boolean delAttribute(const char* name);
    CORBA::Boolean renAttribute(const char* oldName, const char* newName);
    void clearAttributes();
    void printout();
    char* getPrintOut();
    void timeStamp();
    CORBA::Long getSize();
    Position_slice* getPosition();
    Orientation_slice* getOrientation();
    CORBA::Float getConfidence();
    Button getButton();
    void setPosition(const Position pos);
    void setOrientation(const Orientation ori);
    void setConfidence(CORBA::Float value);
    void setButton(Button value);
    CORBA::Boolean addAttribute(const char* type, const char* name, const char* value);
    char* getAttributeValueString(const char* name);

    inline _objref_Event()  { _PR_setobj(0); }  // nil
    _objref_Event(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_Event();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_Event(const _objref_Event&);
    _objref_Event& operator = (const _objref_Event&);
    // not implemented

    friend class Event;
  };

  class _pof_Event : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_Event() : _OMNI_NS(proxyObjectFactory)(Event::_PD_repoId) {}
    virtual ~_pof_Event();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_Event :
    public virtual omniServant
  {
  public:
    virtual ~_impl_Event();

    virtual CORBA::Boolean hasAttribute(const char* name) = 0;
    virtual CORBA::Boolean delAttribute(const char* name) = 0;
    virtual CORBA::Boolean renAttribute(const char* oldName, const char* newName) = 0;
    virtual void clearAttributes() = 0;
    virtual void printout() = 0;
    virtual char* getPrintOut() = 0;
    virtual void timeStamp() = 0;
    virtual CORBA::Long getSize() = 0;
    virtual Position_slice* getPosition() = 0;
    virtual Orientation_slice* getOrientation() = 0;
    virtual CORBA::Float getConfidence() = 0;
    virtual Button getButton() = 0;
    virtual void setPosition(const Position pos) = 0;
    virtual void setOrientation(const Orientation ori) = 0;
    virtual void setConfidence(CORBA::Float value) = 0;
    virtual void setButton(Button value) = 0;
    virtual CORBA::Boolean addAttribute(const char* type, const char* name, const char* value) = 0;
    virtual char* getAttributeValueString(const char* name) = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
  };


  _CORBA_MODULE_VAR _core_attr const char * Event__doc__;

#ifndef __CORBAModule_mOTNode__
#define __CORBAModule_mOTNode__

  class OTNode;
  class _objref_OTNode;
  class _impl_OTNode;
  
  typedef _objref_OTNode* OTNode_ptr;
  typedef OTNode_ptr OTNodeRef;

  class OTNode_Helper {
  public:
    typedef OTNode_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_OTNode, OTNode_Helper> OTNode_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_OTNode,OTNode_Helper > OTNode_out;

#endif

  class OTNode {
  public:
    // Declarations for this interface type.
    typedef OTNode_ptr _ptr_type;
    typedef OTNode_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(CORBA::Object_ptr);
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_OTNode :
    public virtual CORBA::Object, public virtual omniObjRef
  {
  public:
    void push(Event_ptr ev);

    inline _objref_OTNode()  { _PR_setobj(0); }  // nil
    _objref_OTNode(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_OTNode();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_OTNode(const _objref_OTNode&);
    _objref_OTNode& operator = (const _objref_OTNode&);
    // not implemented

    friend class OTNode;
  };

  class _pof_OTNode : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_OTNode() : _OMNI_NS(proxyObjectFactory)(OTNode::_PD_repoId) {}
    virtual ~_pof_OTNode();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_OTNode :
    public virtual omniServant
  {
  public:
    virtual ~_impl_OTNode();

    virtual void push(Event_ptr ev) = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
  };


  _CORBA_MODULE_VAR _core_attr const char * OTNode__doc__;

#ifndef __CORBAModule_mOTSource__
#define __CORBAModule_mOTSource__

  class OTSource;
  class _objref_OTSource;
  class _impl_OTSource;
  
  typedef _objref_OTSource* OTSource_ptr;
  typedef OTSource_ptr OTSourceRef;

  class OTSource_Helper {
  public:
    typedef OTSource_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_OTSource, OTSource_Helper> OTSource_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_OTSource,OTSource_Helper > OTSource_out;

#endif

  class OTSource {
  public:
    // Declarations for this interface type.
    typedef OTSource_ptr _ptr_type;
    typedef OTSource_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(CORBA::Object_ptr);
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_OTSource :
    public virtual _objref_OTNode
  {
  public:
    

    inline _objref_OTSource()  { _PR_setobj(0); }  // nil
    _objref_OTSource(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_OTSource();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_OTSource(const _objref_OTSource&);
    _objref_OTSource& operator = (const _objref_OTSource&);
    // not implemented

    friend class OTSource;
  };

  class _pof_OTSource : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_OTSource() : _OMNI_NS(proxyObjectFactory)(OTSource::_PD_repoId) {}
    virtual ~_pof_OTSource();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_OTSource :
    public virtual _impl_OTNode
  {
  public:
    virtual ~_impl_OTSource();

    
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
  };


#ifndef __CORBAModule_mOTSink__
#define __CORBAModule_mOTSink__

  class OTSink;
  class _objref_OTSink;
  class _impl_OTSink;
  
  typedef _objref_OTSink* OTSink_ptr;
  typedef OTSink_ptr OTSinkRef;

  class OTSink_Helper {
  public:
    typedef OTSink_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_OTSink, OTSink_Helper> OTSink_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_OTSink,OTSink_Helper > OTSink_out;

#endif

  class OTSink {
  public:
    // Declarations for this interface type.
    typedef OTSink_ptr _ptr_type;
    typedef OTSink_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(CORBA::Object_ptr);
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_OTSink :
    public virtual _objref_OTNode
  {
  public:
    

    inline _objref_OTSink()  { _PR_setobj(0); }  // nil
    _objref_OTSink(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_OTSink();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_OTSink(const _objref_OTSink&);
    _objref_OTSink& operator = (const _objref_OTSink&);
    // not implemented

    friend class OTSink;
  };

  class _pof_OTSink : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_OTSink() : _OMNI_NS(proxyObjectFactory)(OTSink::_PD_repoId) {}
    virtual ~_pof_OTSink();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_OTSink :
    public virtual _impl_OTNode
  {
  public:
    virtual ~_impl_OTSink();

    
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
  };


#ifndef __CORBAModule_mNode__
#define __CORBAModule_mNode__

  class Node;
  class _objref_Node;
  class _impl_Node;
  
  typedef _objref_Node* Node_ptr;
  typedef Node_ptr NodeRef;

  class Node_Helper {
  public:
    typedef Node_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_Node, Node_Helper> Node_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_Node,Node_Helper > Node_out;

#endif

  class Node {
  public:
    // Declarations for this interface type.
    typedef Node_ptr _ptr_type;
    typedef Node_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(CORBA::Object_ptr);
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_Node :
    public virtual CORBA::Object, public virtual omniObjRef
  {
  public:
    void _cxx_register(OTNode_ptr node);
    void deregister(OTNode_ptr node);

    inline _objref_Node()  { _PR_setobj(0); }  // nil
    _objref_Node(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_Node();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_Node(const _objref_Node&);
    _objref_Node& operator = (const _objref_Node&);
    // not implemented

    friend class Node;
  };

  class _pof_Node : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_Node() : _OMNI_NS(proxyObjectFactory)(Node::_PD_repoId) {}
    virtual ~_pof_Node();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_Node :
    public virtual omniServant
  {
  public:
    virtual ~_impl_Node();

    virtual void _cxx_register(OTNode_ptr node) = 0;
    virtual void deregister(OTNode_ptr node) = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
  };


#ifndef __CORBAModule_mSource__
#define __CORBAModule_mSource__

  class Source;
  class _objref_Source;
  class _impl_Source;
  
  typedef _objref_Source* Source_ptr;
  typedef Source_ptr SourceRef;

  class Source_Helper {
  public:
    typedef Source_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_Source, Source_Helper> Source_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_Source,Source_Helper > Source_out;

#endif

  class Source {
  public:
    // Declarations for this interface type.
    typedef Source_ptr _ptr_type;
    typedef Source_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(CORBA::Object_ptr);
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_Source :
    public virtual _objref_Node
  {
  public:
    

    inline _objref_Source()  { _PR_setobj(0); }  // nil
    _objref_Source(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_Source();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_Source(const _objref_Source&);
    _objref_Source& operator = (const _objref_Source&);
    // not implemented

    friend class Source;
  };

  class _pof_Source : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_Source() : _OMNI_NS(proxyObjectFactory)(Source::_PD_repoId) {}
    virtual ~_pof_Source();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_Source :
    public virtual _impl_Node
  {
  public:
    virtual ~_impl_Source();

    
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
  };


#ifndef __CORBAModule_mSink__
#define __CORBAModule_mSink__

  class Sink;
  class _objref_Sink;
  class _impl_Sink;
  
  typedef _objref_Sink* Sink_ptr;
  typedef Sink_ptr SinkRef;

  class Sink_Helper {
  public:
    typedef Sink_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_Sink, Sink_Helper> Sink_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_Sink,Sink_Helper > Sink_out;

#endif

  class Sink {
  public:
    // Declarations for this interface type.
    typedef Sink_ptr _ptr_type;
    typedef Sink_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(CORBA::Object_ptr);
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_Sink :
    public virtual _objref_Node
  {
  public:
    

    inline _objref_Sink()  { _PR_setobj(0); }  // nil
    _objref_Sink(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_Sink();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_Sink(const _objref_Sink&);
    _objref_Sink& operator = (const _objref_Sink&);
    // not implemented

    friend class Sink;
  };

  class _pof_Sink : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_Sink() : _OMNI_NS(proxyObjectFactory)(Sink::_PD_repoId) {}
    virtual ~_pof_Sink();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_Sink :
    public virtual _impl_Node
  {
  public:
    virtual ~_impl_Sink();

    
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
  };


_CORBA_MODULE_END



_CORBA_MODULE POA_CORBAModule
_CORBA_MODULE_BEG

  class Event :
    public virtual CORBAModule::_impl_Event,
    public virtual PortableServer::ServantBase
  {
  public:
    virtual ~Event();

    inline ::CORBAModule::Event_ptr _this() {
      return (::CORBAModule::Event_ptr) _do_this(::CORBAModule::Event::_PD_repoId);
    }
  };

  template <class _omniT>
  class Event_tie : public virtual Event
  {
  public:
    Event_tie(_omniT& t)
      : pd_obj(&t), pd_poa(0), pd_rel(0) {}
    Event_tie(_omniT& t, PortableServer::POA_ptr p)
      : pd_obj(&t), pd_poa(p), pd_rel(0) {}
    Event_tie(_omniT* t, CORBA::Boolean r=1)
      : pd_obj(t), pd_poa(0), pd_rel(r) {}
    Event_tie(_omniT* t, PortableServer::POA_ptr p,CORBA::Boolean r=1)
      : pd_obj(t), pd_poa(p), pd_rel(r) {}
    ~Event_tie() {
      if( pd_poa )  CORBA::release(pd_poa);
      if( pd_rel )  delete pd_obj;
    }

    _omniT* _tied_object() { return pd_obj; }

    void _tied_object(_omniT& t) {
      if( pd_rel )  delete pd_obj;
      pd_obj = &t;
      pd_rel = 0;
    }

    void _tied_object(_omniT* t, CORBA::Boolean r=1) {
      if( pd_rel )  delete pd_obj;
      pd_obj = t;
      pd_rel = r;
    }

    CORBA::Boolean _is_owner()        { return pd_rel; }
    void _is_owner(CORBA::Boolean io) { pd_rel = io;   }

    PortableServer::POA_ptr _default_POA() {
      if( !pd_poa )  return PortableServer::POA::_the_root_poa();
      else           return PortableServer::POA::_duplicate(pd_poa);
    }

    CORBA::Boolean hasAttribute(const char* name) { return pd_obj->hasAttribute(name); }
    CORBA::Boolean delAttribute(const char* name) { return pd_obj->delAttribute(name); }
    CORBA::Boolean renAttribute(const char* oldName, const char* newName) { return pd_obj->renAttribute(oldName, newName); }
    void clearAttributes() { pd_obj->clearAttributes(); }
    void printout() { pd_obj->printout(); }
    char* getPrintOut() { return pd_obj->getPrintOut(); }
    void timeStamp() { pd_obj->timeStamp(); }
    CORBA::Long getSize() { return pd_obj->getSize(); }
    CORBAModule::Position_slice* getPosition() { return pd_obj->getPosition(); }
    CORBAModule::Orientation_slice* getOrientation() { return pd_obj->getOrientation(); }
    CORBA::Float getConfidence() { return pd_obj->getConfidence(); }
    CORBAModule::Button getButton() { return pd_obj->getButton(); }
    void setPosition(const CORBAModule::Position pos) { pd_obj->setPosition(pos); }
    void setOrientation(const CORBAModule::Orientation ori) { pd_obj->setOrientation(ori); }
    void setConfidence(CORBA::Float value) { pd_obj->setConfidence(value); }
    void setButton(CORBAModule::Button value) { pd_obj->setButton(value); }
    CORBA::Boolean addAttribute(const char* type, const char* name, const char* value) { return pd_obj->addAttribute(type, name, value); }
    char* getAttributeValueString(const char* name) { return pd_obj->getAttributeValueString(name); }
  

  private:
    _omniT*                 pd_obj;
    PortableServer::POA_ptr pd_poa;
    CORBA::Boolean          pd_rel;
  };

  class OTNode :
    public virtual CORBAModule::_impl_OTNode,
    public virtual PortableServer::ServantBase
  {
  public:
    virtual ~OTNode();

    inline ::CORBAModule::OTNode_ptr _this() {
      return (::CORBAModule::OTNode_ptr) _do_this(::CORBAModule::OTNode::_PD_repoId);
    }
  };

  template <class _omniT>
  class OTNode_tie : public virtual OTNode
  {
  public:
    OTNode_tie(_omniT& t)
      : pd_obj(&t), pd_poa(0), pd_rel(0) {}
    OTNode_tie(_omniT& t, PortableServer::POA_ptr p)
      : pd_obj(&t), pd_poa(p), pd_rel(0) {}
    OTNode_tie(_omniT* t, CORBA::Boolean r=1)
      : pd_obj(t), pd_poa(0), pd_rel(r) {}
    OTNode_tie(_omniT* t, PortableServer::POA_ptr p,CORBA::Boolean r=1)
      : pd_obj(t), pd_poa(p), pd_rel(r) {}
    ~OTNode_tie() {
      if( pd_poa )  CORBA::release(pd_poa);
      if( pd_rel )  delete pd_obj;
    }

    _omniT* _tied_object() { return pd_obj; }

    void _tied_object(_omniT& t) {
      if( pd_rel )  delete pd_obj;
      pd_obj = &t;
      pd_rel = 0;
    }

    void _tied_object(_omniT* t, CORBA::Boolean r=1) {
      if( pd_rel )  delete pd_obj;
      pd_obj = t;
      pd_rel = r;
    }

    CORBA::Boolean _is_owner()        { return pd_rel; }
    void _is_owner(CORBA::Boolean io) { pd_rel = io;   }

    PortableServer::POA_ptr _default_POA() {
      if( !pd_poa )  return PortableServer::POA::_the_root_poa();
      else           return PortableServer::POA::_duplicate(pd_poa);
    }

    void push(CORBAModule::Event_ptr ev) { pd_obj->push(ev); }
  

  private:
    _omniT*                 pd_obj;
    PortableServer::POA_ptr pd_poa;
    CORBA::Boolean          pd_rel;
  };

  class OTSource :
    public virtual CORBAModule::_impl_OTSource,
    public virtual OTNode
  {
  public:
    virtual ~OTSource();

    inline ::CORBAModule::OTSource_ptr _this() {
      return (::CORBAModule::OTSource_ptr) _do_this(::CORBAModule::OTSource::_PD_repoId);
    }
  };

  template <class _omniT>
  class OTSource_tie : public virtual OTSource
  {
  public:
    OTSource_tie(_omniT& t)
      : pd_obj(&t), pd_poa(0), pd_rel(0) {}
    OTSource_tie(_omniT& t, PortableServer::POA_ptr p)
      : pd_obj(&t), pd_poa(p), pd_rel(0) {}
    OTSource_tie(_omniT* t, CORBA::Boolean r=1)
      : pd_obj(t), pd_poa(0), pd_rel(r) {}
    OTSource_tie(_omniT* t, PortableServer::POA_ptr p,CORBA::Boolean r=1)
      : pd_obj(t), pd_poa(p), pd_rel(r) {}
    ~OTSource_tie() {
      if( pd_poa )  CORBA::release(pd_poa);
      if( pd_rel )  delete pd_obj;
    }

    _omniT* _tied_object() { return pd_obj; }

    void _tied_object(_omniT& t) {
      if( pd_rel )  delete pd_obj;
      pd_obj = &t;
      pd_rel = 0;
    }

    void _tied_object(_omniT* t, CORBA::Boolean r=1) {
      if( pd_rel )  delete pd_obj;
      pd_obj = t;
      pd_rel = r;
    }

    CORBA::Boolean _is_owner()        { return pd_rel; }
    void _is_owner(CORBA::Boolean io) { pd_rel = io;   }

    PortableServer::POA_ptr _default_POA() {
      if( !pd_poa )  return PortableServer::POA::_the_root_poa();
      else           return PortableServer::POA::_duplicate(pd_poa);
    }

    void push(CORBAModule::Event_ptr ev) { pd_obj->push(ev); }
  

  private:
    _omniT*                 pd_obj;
    PortableServer::POA_ptr pd_poa;
    CORBA::Boolean          pd_rel;
  };

  class OTSink :
    public virtual CORBAModule::_impl_OTSink,
    public virtual OTNode
  {
  public:
    virtual ~OTSink();

    inline ::CORBAModule::OTSink_ptr _this() {
      return (::CORBAModule::OTSink_ptr) _do_this(::CORBAModule::OTSink::_PD_repoId);
    }
  };

  template <class _omniT>
  class OTSink_tie : public virtual OTSink
  {
  public:
    OTSink_tie(_omniT& t)
      : pd_obj(&t), pd_poa(0), pd_rel(0) {}
    OTSink_tie(_omniT& t, PortableServer::POA_ptr p)
      : pd_obj(&t), pd_poa(p), pd_rel(0) {}
    OTSink_tie(_omniT* t, CORBA::Boolean r=1)
      : pd_obj(t), pd_poa(0), pd_rel(r) {}
    OTSink_tie(_omniT* t, PortableServer::POA_ptr p,CORBA::Boolean r=1)
      : pd_obj(t), pd_poa(p), pd_rel(r) {}
    ~OTSink_tie() {
      if( pd_poa )  CORBA::release(pd_poa);
      if( pd_rel )  delete pd_obj;
    }

    _omniT* _tied_object() { return pd_obj; }

    void _tied_object(_omniT& t) {
      if( pd_rel )  delete pd_obj;
      pd_obj = &t;
      pd_rel = 0;
    }

    void _tied_object(_omniT* t, CORBA::Boolean r=1) {
      if( pd_rel )  delete pd_obj;
      pd_obj = t;
      pd_rel = r;
    }

    CORBA::Boolean _is_owner()        { return pd_rel; }
    void _is_owner(CORBA::Boolean io) { pd_rel = io;   }

    PortableServer::POA_ptr _default_POA() {
      if( !pd_poa )  return PortableServer::POA::_the_root_poa();
      else           return PortableServer::POA::_duplicate(pd_poa);
    }

    void push(CORBAModule::Event_ptr ev) { pd_obj->push(ev); }
  

  private:
    _omniT*                 pd_obj;
    PortableServer::POA_ptr pd_poa;
    CORBA::Boolean          pd_rel;
  };

  class Node :
    public virtual CORBAModule::_impl_Node,
    public virtual PortableServer::ServantBase
  {
  public:
    virtual ~Node();

    inline ::CORBAModule::Node_ptr _this() {
      return (::CORBAModule::Node_ptr) _do_this(::CORBAModule::Node::_PD_repoId);
    }
  };

  template <class _omniT>
  class Node_tie : public virtual Node
  {
  public:
    Node_tie(_omniT& t)
      : pd_obj(&t), pd_poa(0), pd_rel(0) {}
    Node_tie(_omniT& t, PortableServer::POA_ptr p)
      : pd_obj(&t), pd_poa(p), pd_rel(0) {}
    Node_tie(_omniT* t, CORBA::Boolean r=1)
      : pd_obj(t), pd_poa(0), pd_rel(r) {}
    Node_tie(_omniT* t, PortableServer::POA_ptr p,CORBA::Boolean r=1)
      : pd_obj(t), pd_poa(p), pd_rel(r) {}
    ~Node_tie() {
      if( pd_poa )  CORBA::release(pd_poa);
      if( pd_rel )  delete pd_obj;
    }

    _omniT* _tied_object() { return pd_obj; }

    void _tied_object(_omniT& t) {
      if( pd_rel )  delete pd_obj;
      pd_obj = &t;
      pd_rel = 0;
    }

    void _tied_object(_omniT* t, CORBA::Boolean r=1) {
      if( pd_rel )  delete pd_obj;
      pd_obj = t;
      pd_rel = r;
    }

    CORBA::Boolean _is_owner()        { return pd_rel; }
    void _is_owner(CORBA::Boolean io) { pd_rel = io;   }

    PortableServer::POA_ptr _default_POA() {
      if( !pd_poa )  return PortableServer::POA::_the_root_poa();
      else           return PortableServer::POA::_duplicate(pd_poa);
    }

    void _cxx_register(CORBAModule::OTNode_ptr node) { pd_obj->_cxx_register(node); }
    void deregister(CORBAModule::OTNode_ptr node) { pd_obj->deregister(node); }
  

  private:
    _omniT*                 pd_obj;
    PortableServer::POA_ptr pd_poa;
    CORBA::Boolean          pd_rel;
  };

  class Source :
    public virtual CORBAModule::_impl_Source,
    public virtual Node
  {
  public:
    virtual ~Source();

    inline ::CORBAModule::Source_ptr _this() {
      return (::CORBAModule::Source_ptr) _do_this(::CORBAModule::Source::_PD_repoId);
    }
  };

  template <class _omniT>
  class Source_tie : public virtual Source
  {
  public:
    Source_tie(_omniT& t)
      : pd_obj(&t), pd_poa(0), pd_rel(0) {}
    Source_tie(_omniT& t, PortableServer::POA_ptr p)
      : pd_obj(&t), pd_poa(p), pd_rel(0) {}
    Source_tie(_omniT* t, CORBA::Boolean r=1)
      : pd_obj(t), pd_poa(0), pd_rel(r) {}
    Source_tie(_omniT* t, PortableServer::POA_ptr p,CORBA::Boolean r=1)
      : pd_obj(t), pd_poa(p), pd_rel(r) {}
    ~Source_tie() {
      if( pd_poa )  CORBA::release(pd_poa);
      if( pd_rel )  delete pd_obj;
    }

    _omniT* _tied_object() { return pd_obj; }

    void _tied_object(_omniT& t) {
      if( pd_rel )  delete pd_obj;
      pd_obj = &t;
      pd_rel = 0;
    }

    void _tied_object(_omniT* t, CORBA::Boolean r=1) {
      if( pd_rel )  delete pd_obj;
      pd_obj = t;
      pd_rel = r;
    }

    CORBA::Boolean _is_owner()        { return pd_rel; }
    void _is_owner(CORBA::Boolean io) { pd_rel = io;   }

    PortableServer::POA_ptr _default_POA() {
      if( !pd_poa )  return PortableServer::POA::_the_root_poa();
      else           return PortableServer::POA::_duplicate(pd_poa);
    }

    void _cxx_register(CORBAModule::OTNode_ptr node) { pd_obj->_cxx_register(node); }
    void deregister(CORBAModule::OTNode_ptr node) { pd_obj->deregister(node); }
  

  private:
    _omniT*                 pd_obj;
    PortableServer::POA_ptr pd_poa;
    CORBA::Boolean          pd_rel;
  };

  class Sink :
    public virtual CORBAModule::_impl_Sink,
    public virtual Node
  {
  public:
    virtual ~Sink();

    inline ::CORBAModule::Sink_ptr _this() {
      return (::CORBAModule::Sink_ptr) _do_this(::CORBAModule::Sink::_PD_repoId);
    }
  };

  template <class _omniT>
  class Sink_tie : public virtual Sink
  {
  public:
    Sink_tie(_omniT& t)
      : pd_obj(&t), pd_poa(0), pd_rel(0) {}
    Sink_tie(_omniT& t, PortableServer::POA_ptr p)
      : pd_obj(&t), pd_poa(p), pd_rel(0) {}
    Sink_tie(_omniT* t, CORBA::Boolean r=1)
      : pd_obj(t), pd_poa(0), pd_rel(r) {}
    Sink_tie(_omniT* t, PortableServer::POA_ptr p,CORBA::Boolean r=1)
      : pd_obj(t), pd_poa(p), pd_rel(r) {}
    ~Sink_tie() {
      if( pd_poa )  CORBA::release(pd_poa);
      if( pd_rel )  delete pd_obj;
    }

    _omniT* _tied_object() { return pd_obj; }

    void _tied_object(_omniT& t) {
      if( pd_rel )  delete pd_obj;
      pd_obj = &t;
      pd_rel = 0;
    }

    void _tied_object(_omniT* t, CORBA::Boolean r=1) {
      if( pd_rel )  delete pd_obj;
      pd_obj = t;
      pd_rel = r;
    }

    CORBA::Boolean _is_owner()        { return pd_rel; }
    void _is_owner(CORBA::Boolean io) { pd_rel = io;   }

    PortableServer::POA_ptr _default_POA() {
      if( !pd_poa )  return PortableServer::POA::_the_root_poa();
      else           return PortableServer::POA::_duplicate(pd_poa);
    }

    void _cxx_register(CORBAModule::OTNode_ptr node) { pd_obj->_cxx_register(node); }
    void deregister(CORBAModule::OTNode_ptr node) { pd_obj->deregister(node); }
  

  private:
    _omniT*                 pd_obj;
    PortableServer::POA_ptr pd_poa;
    CORBA::Boolean          pd_rel;
  };

_CORBA_MODULE_END





#undef _core_attr
#undef _dyn_attr



inline void
CORBAModule::Event::_marshalObjRef(::CORBAModule::Event_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
CORBAModule::OTNode::_marshalObjRef(::CORBAModule::OTNode_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
CORBAModule::OTSource::_marshalObjRef(::CORBAModule::OTSource_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
CORBAModule::OTSink::_marshalObjRef(::CORBAModule::OTSink_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
CORBAModule::Node::_marshalObjRef(::CORBAModule::Node_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
CORBAModule::Source::_marshalObjRef(::CORBAModule::Source_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
CORBAModule::Sink::_marshalObjRef(::CORBAModule::Sink_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}




#ifdef   USE_core_stub_in_nt_dll_NOT_DEFINED_OT__CORBA
# undef  USE_core_stub_in_nt_dll
# undef  USE_core_stub_in_nt_dll_NOT_DEFINED_OT__CORBA
#endif
#ifdef   USE_dyn_stub_in_nt_dll_NOT_DEFINED_OT__CORBA
# undef  USE_dyn_stub_in_nt_dll
# undef  USE_dyn_stub_in_nt_dll_NOT_DEFINED_OT__CORBA
#endif

#endif  // __OT__CORBA_hh__

