<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SoVRMLExtrusion class Reference</title>
<link href="stylesheet.css" rel="stylesheet" type="text/css">
</head><body><table width="100%">
<tr>
  <td>
    <img src="Coin_logo.png" alt="Coin Logo">
  </td>
  <td align="right">
    <a href="http://www.sim.no">http://www.sim.no</a><br>
    <a href="http://www.coin3d.org/">http://www.coin3d.org</a>
  </td>
</tr>
</table>
<hr noshade>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>SoVRMLExtrusion Class Reference<br>
<small>
[<a class="el" href="group__VRMLnodes.html">VRML97 classes</a>]</small>
</h1><code>#include &lt;<a class="el" href="SoVRMLExtrusion_8h-source.html">Inventor/VRMLnodes/SoVRMLExtrusion.h</a>&gt;</code>
<p>
<p>Inheritance diagram for SoVRMLExtrusion:
<p><center><img src="classSoVRMLExtrusion.png" usemap="#SoVRMLExtrusion_map" border="0" alt=""></center>
<map name="SoVRMLExtrusion_map">
<area href="classSoVRMLGeometry.html" alt="SoVRMLGeometry" shape="rect" coords="0,224,116,248">
<area href="classSoShape.html" alt="SoShape" shape="rect" coords="0,168,116,192">
<area href="classSoNode.html" alt="SoNode" shape="rect" coords="0,112,116,136">
<area href="classSoFieldContainer.html" alt="SoFieldContainer" shape="rect" coords="0,56,116,80">
<area href="classSoBase.html" alt="SoBase" shape="rect" coords="0,0,116,24">
</map>
<a href="classSoVRMLExtrusion-members.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>
The SoVRMLExtrusion class is a a geometry node for extruding a cross section along a spine. 
<p>
<b>The detailed class documentation is taken verbatim from the VRML97 standard (ISO/IEC 14772-1:1997). It is copyright The Web3D Consortium, and is used by permission of the Consortium:</b><p>
<pre><div class="fragment">
  Extrusion {
    eventIn MFVec2f    set_crossSection
    eventIn MFRotation set_orientation
    eventIn MFVec2f    set_scale
    eventIn MFVec3f    set_spine
    field   SFBool     beginCap         TRUE
    field   SFBool     ccw              TRUE
    field   SFBool     convex           TRUE
    field   SFFloat    creaseAngle      0                # [0,inf)
    field   MFVec2f    crossSection     [ 1 1, 1 -1, -1 -1, -1 1, 1  1 ]    # (-inf,inf)
    field   SFBool     endCap           TRUE
    field   MFRotation orientation      0 0 1 0          # [-1,1],(-inf,inf)
    field   MFVec2f    scale            1 1              # (0,inf)
    field   SFBool     solid            TRUE
    field   MFVec3f    spine            [ 0 0 0, 0 1 0 ] # (-inf,inf)
  }
  </div></pre><p>
<em>Introduction</em> <p>
The Extrusion node specifies geometric shapes based on a two dimensional cross-section extruded along a three dimensional spine in the local coordinate system. The cross-section can be scaled and rotated at each spine point to produce a wide variety of shapes. An Extrusion node is defined by:<p>
<ul>
<li>a 2D crossSection piecewise linear curve (described as a series of connected vertices);</li>
</ul>
<ul>
<li>a 3D spine piecewise linear curve (also described as a series of connected vertices);</li>
</ul>
<ul>
<li>a list of 2D scale parameters;</li>
</ul>
<ul>
<li>a list of 3D orientation parameters.</li>
</ul>
<em>Algorithmic</em> <em>description</em> <p>
Shapes are constructed as follows. The cross-section curve, which starts as a curve in the Y=0 plane, is first scaled about the origin by the first scale parameter (first value scales in X, second value scales in Z). It is then translated by the first spine point and oriented using the first orientation parameter (as explained later). The same procedure is followed to place a cross- section at the second spine point, using the second scale and orientation values. Corresponding vertices of the first and second cross-sections are then connected, forming a quadrilateral polygon between each pair of vertices. This same procedure is then repeated for the rest of the spine points, resulting in a surface extrusion along the spine.<p>
The final orientation of each cross-section is computed by first orienting it relative to the spine segments on either side of point at which the cross-section is placed. This is known as the spine-aligned cross-section plane (SCP), and is designed to provide a smooth transition from one spine segment to the next (see Figure 6.6). The SCP is then rotated by the corresponding orientation value. This rotation is performed relative to the SCP. For example, to impart twist in the cross- section, a rotation about the Y-axis (0 1 0) would be used. Other orientations are valid and rotate the cross-section out of the SCP.<p>
<center> <div align="center">
<img src="http://www.web3d.org/technicalinfo/specifications/vrml97/Images/Extrusion.gif" alt="Extrusion.gif">
</div>
 Figure 6.6 </center><p>
The SCP is computed by first computing its Y-axis and Z-axis, then taking the cross product of these to determine the X-axis. These three axes are then used to determine the rotation value needed to rotate the Y=0 plane to the SCP. This results in a plane that is the approximate tangent of the spine at each point, as shown in Figure 6.6. First the Y-axis is determined, as follows:<p>
Let n be the number of spines and let i be the index variable satisfying 0 &lt;= i &lt; n:<p>
<ul>
<li>For all points other than the first or last: The Y-axis for spine[i] is found by normalizing the vector defined by (spine[i+1]<ul>
<li>spine[i-1]).</li></ul>
</li>
</ul>
<ul>
<li>If the spine curve is closed: The SCP for the first and last points is the same and is found using (spine[1] - spine[n-2]) to compute the Y-axis.</li>
</ul>
<ul>
<li>If the spine curve is not closed: The Y-axis used for the first point is the vector from spine[0] to spine[1], and for the last it is the vector from spine[n-2] to spine[n-1].</li>
</ul>
The Z-axis is determined as follows:<p>
<ul>
<li>For all points other than the first or last: Take the following cross-product:</li>
</ul>
<pre><div class="fragment">
  Z = (spine[i+1] - spine[i]) × (spine[i-1] - spine[i])
  </div></pre><p>
<ul>
<li>If the spine curve is closed: The SCP for the first and last points is the same and is found by taking the following cross- product:</li>
</ul>
<pre><div class="fragment">
  Z = (spine[1] - spine[0]) × (spine[n-2] - spine[0])
  </div></pre><p>
<ul>
<li>If the spine curve is not closed: The Z-axis used for the first spine point is the same as the Z-axis for spine[1]. The Z- axis used for the last spine point is the same as the Z-axis for spine[n-2].</li>
</ul>
<ul>
<li>After determining the Z-axis, its dot product with the Z-axis of the previous spine point is computed. If this value is negative, the Z-axis is flipped (multiplied by -1). In most cases, this prevents small changes in the spine segment angles from flipping the cross-section 180 degrees.</li>
</ul>
Once the Y- and Z-axes have been computed, the X-axis can be calculated as their cross-product.<p>
<em>Special</em> <em>Cases</em> <p>
If the number of scale or orientation values is greater than the number of spine points, the excess values are ignored. If they contain one value, it is applied at all spine points. The results are undefined if the number of scale or orientation values is greater than one but less than the number of spine points. The scale values shall be positive.<p>
If the three points used in computing the Z-axis are collinear, the cross-product is zero so the value from the previous point is used instead. If the Z-axis of the first point is undefined (because the spine is not closed and the first two spine segments are collinear) then the Z-axis for the first spine point with a defined Z-axis is used.<p>
If the entire spine is collinear, the SCP is computed by finding the rotation of a vector along the positive Y-axis (v1) to the vector formed by the spine points (v2). The Y=0 plane is then rotated by this value. If two points are coincident, they both have the same SCP. If each point has a different orientation value, then the surface is constructed by connecting edges of the cross-sections as normal. This is useful in creating revolved surfaces.<p>
Note: combining coincident and non-coincident spine segments, as well as other combinations, can lead to interpenetrating surfaces which the extrusion algorithm makes no attempt to avoid.<p>
<em>Common</em> <em>Cases</em> <p>
The following common cases are among the effects which are supported by the Extrusion node:<p>
<ul>
<li>Surfaces of revolution: If the cross-section is an approximation of a circle and the spine is straight, the Extrusion is equivalent to a surface of revolution, where the scale parameters define the size of the cross-section along the spine.</li>
</ul>
<ul>
<li>Uniform extrusions: If the scale is (1, 1) and the spine is straight, the cross-section is extruded uniformly without twisting or scaling along the spine. The result is a cylindrical shape with a uniform cross section.</li>
</ul>
<ul>
<li>Bend/twist/taper objects: These shapes are the result of using all fields. The spine curve bends the extruded shape defined by the cross-section, the orientation parameters (given as rotations about the Y-axis) twist it around the spine, and the scale parameters taper it (by scaling about the spine).</li>
</ul>
<em>Other</em> <em>Fields</em> <p>
Extrusion has three parts: the sides, the beginCap (the surface at the initial end of the spine) and the endCap (the surface at the final end of the spine). The caps have an associated SFBool field that indicates whether each exists (TRUE) or doesn't exist (FALSE).<p>
When the beginCap or endCap fields are specified as TRUE, planar cap surfaces will be generated regardless of whether the crossSection is a closed curve. If crossSection is not a closed curve, the caps are generated by adding a final point to crossSection that is equal to the initial point. An open surface can still have a cap, resulting (for a simple case) in a shape analogous to a soda can sliced in half vertically. These surfaces are generated even if spine is also a closed curve. If a field value is FALSE, the corresponding cap is not generated.<p>
Texture coordinates are automatically generated by Extrusion nodes. Textures are mapped so that the coordinates range in the U direction from 0 to 1 along the crossSection curve (with 0 corresponding to the first point in crossSection and 1 to the last) and in the V direction from 0 to 1 along the spine curve (with 0 corresponding to the first listed spine point and 1 to the last). If either the endCap or beginCap exists, the crossSection curve is uniformly scaled and translated so that the larger dimension of the cross-section (X or Z) produces texture coordinates that range from 0.0 to 1.0. The beginCap and endCap textures' S and T directions correspond to the X and Z directions in which the crossSection coordinates are defined.<p>
The browser shall automatically generate normals for the Extrusion node,using the creaseAngle field to determine if and how normals are smoothed across the surface. Normals for the caps are generated along the Y-axis of the SCP, with the ordering determined by viewing the cross-section from above (looking along the negative Y-axis of the SCP). By default, a beginCap with a counterclockwise ordering shall have a normal along the negative Y-axis. An endCap with a counterclockwise ordering shall have a normal along the positive Y-axis.<p>
Each quadrilateral making up the sides of the extrusion are ordered from the bottom cross-section (the one at the earlier spine point) to the top. So, one quadrilateral has the points:<p>
<pre><div class="fragment">
  spine[0](crossSection[0], crossSection[1])
  spine[1](crossSection[1], crossSection[0])
  </div></pre><p>
in that order. By default, normals for the sides are generated as described in 4.6.3, Shapes and geometry (&lt;<a href="http://www.web3d.org/technicalinfo/specifications/vrml97/part1/concepts.html#4.6.3">http://www.web3d.org/technicalinfo/specifications/vrml97/part1/concepts.html#4.6.3</a>&gt;).<p>
For instance, a circular crossSection with counter-clockwise ordering and the default spine form a cylinder. With solid TRUE and ccw TRUE, the cylinder is visible from the outside. Changing ccw to FALSE makes it visible from the inside. The ccw, solid, convex, and creaseAngle fields are described in 4.6.3, Shapes and geometry (&lt;<a href="http://www.web3d.org/technicalinfo/specifications/vrml97/part1/concepts.html#4.6.3">http://www.web3d.org/technicalinfo/specifications/vrml97/part1/concepts.html#4.6.3</a>&gt;). 
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>virtual <a class="el" href="classSoType.html">SoType</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoVRMLExtrusion.html#a0">getTypeId</a> (void) const</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoVRMLExtrusion.html#a1">SoVRMLExtrusion</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoVRMLExtrusion.html#a2">GLRender</a> (<a class="el" href="classSoGLRenderAction.html">SoGLRenderAction</a> *action)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoVRMLExtrusion.html#a3">getPrimitiveCount</a> (<a class="el" href="classSoGetPrimitiveCountAction.html">SoGetPrimitiveCountAction</a> *action)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoVRMLExtrusion.html#a4">computeBBox</a> (<a class="el" href="classSoAction.html">SoAction</a> *action, <a class="el" href="classSbBox3f.html">SbBox3f</a> &amp;bbox, <a class="el" href="classSbVec3f.html">SbVec3f</a> &amp;center)</td></tr>

<tr><td colspan=2><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="classSoType.html">SoType</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoVRMLExtrusion.html#e0">getClassTypeId</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoVRMLExtrusion.html#e1">initClass</a> (void)</td></tr>

<tr><td colspan=2><br><h2>Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="o0" doxytag="SoVRMLExtrusion::beginCap" ></a>
<a class="el" href="classSoSFBool.html">SoSFBool</a>&nbsp;</td><td class="memItemRight" valign=bottom><b>beginCap</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="o1" doxytag="SoVRMLExtrusion::ccw" ></a>
<a class="el" href="classSoSFBool.html">SoSFBool</a>&nbsp;</td><td class="memItemRight" valign=bottom><b>ccw</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="o2" doxytag="SoVRMLExtrusion::convex" ></a>
<a class="el" href="classSoSFBool.html">SoSFBool</a>&nbsp;</td><td class="memItemRight" valign=bottom><b>convex</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="o3" doxytag="SoVRMLExtrusion::creaseAngle" ></a>
<a class="el" href="classSoSFFloat.html">SoSFFloat</a>&nbsp;</td><td class="memItemRight" valign=bottom><b>creaseAngle</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="o4" doxytag="SoVRMLExtrusion::crossSection" ></a>
<a class="el" href="classSoMFVec2f.html">SoMFVec2f</a>&nbsp;</td><td class="memItemRight" valign=bottom><b>crossSection</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="o5" doxytag="SoVRMLExtrusion::endCap" ></a>
<a class="el" href="classSoSFBool.html">SoSFBool</a>&nbsp;</td><td class="memItemRight" valign=bottom><b>endCap</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="o6" doxytag="SoVRMLExtrusion::orientation" ></a>
<a class="el" href="classSoMFRotation.html">SoMFRotation</a>&nbsp;</td><td class="memItemRight" valign=bottom><b>orientation</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="o7" doxytag="SoVRMLExtrusion::scale" ></a>
<a class="el" href="classSoMFVec2f.html">SoMFVec2f</a>&nbsp;</td><td class="memItemRight" valign=bottom><b>scale</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="o8" doxytag="SoVRMLExtrusion::solid" ></a>
<a class="el" href="classSoSFBool.html">SoSFBool</a>&nbsp;</td><td class="memItemRight" valign=bottom><b>solid</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="o9" doxytag="SoVRMLExtrusion::spine" ></a>
<a class="el" href="classSoMFVec3f.html">SoMFVec3f</a>&nbsp;</td><td class="memItemRight" valign=bottom><b>spine</b></td></tr>

<tr><td colspan=2><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>virtual const <a class="el" href="classSoFieldData.html">SoFieldData</a> *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoVRMLExtrusion.html#b0">getFieldData</a> (void) const</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoVRMLExtrusion.html#b1">~SoVRMLExtrusion</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoVRMLExtrusion.html#b2">notify</a> (<a class="el" href="classSoNotList.html">SoNotList</a> *list)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoVRMLExtrusion.html#b3">generatePrimitives</a> (<a class="el" href="classSoAction.html">SoAction</a> *action)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual <a class="el" href="classSoDetail.html">SoDetail</a> *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoVRMLExtrusion.html#b4">createTriangleDetail</a> (<a class="el" href="classSoRayPickAction.html">SoRayPickAction</a> *action, const <a class="el" href="classSoPrimitiveVertex.html">SoPrimitiveVertex</a> *v1, const <a class="el" href="classSoPrimitiveVertex.html">SoPrimitiveVertex</a> *v2, const <a class="el" href="classSoPrimitiveVertex.html">SoPrimitiveVertex</a> *v3, <a class="el" href="classSoPickedPoint.html">SoPickedPoint</a> *pp)</td></tr>

<tr><td colspan=2><br><h2>Static Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>const <a class="el" href="classSoFieldData.html">SoFieldData</a> **&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoVRMLExtrusion.html#f0">getFieldDataPtr</a> (void)</td></tr>

</table>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="a1" doxytag="SoVRMLExtrusion::SoVRMLExtrusion" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> SoVRMLExtrusion::SoVRMLExtrusion           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Constructor.     </td>
  </tr>
</table>
<a class="anchor" name="b1" doxytag="SoVRMLExtrusion::~SoVRMLExtrusion" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> SoVRMLExtrusion::~<a class="el" href="classSoVRMLExtrusion.html">SoVRMLExtrusion</a>           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [protected, virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Destructor.     </td>
  </tr>
</table>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="e0" doxytag="SoVRMLExtrusion::getClassTypeId" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classSoType.html">SoType</a> SoVRMLExtrusion::getClassTypeId           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This static method returns the <a class="el" href="classSoType.html">SoType</a> object associated with objects of this class. 
<p>
Reimplemented from <a class="el" href="classSoVRMLGeometry.html#e0">SoVRMLGeometry</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a0" doxytag="SoVRMLExtrusion::getTypeId" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classSoType.html">SoType</a> SoVRMLExtrusion::getTypeId           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the type identification of an object derived from a class inheriting <a class="el" href="classSoBase.html">SoBase</a>. This is used for run-time type checking and "downward" casting.<p>
Usage example:<p>
<pre><div class="fragment">  <span class="keywordtype">void</span> foo(<a class="code" href="classSoNode.html">SoNode</a> * node)
  {
    <span class="keywordflow">if</span> (node-&gt;<a class="code" href="classSoBase.html#a5">getTypeId</a>() == <a class="code" href="classSoFile.html#e0">SoFile::getClassTypeId</a>()) {
      <a class="code" href="classSoFile.html">SoFile</a> * filenode = (<a class="code" href="classSoFile.html">SoFile</a> *)node;  <span class="comment">// safe downward cast, knows the type</span>
<span class="comment"></span>    }
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (node-&gt;<a class="code" href="classSoBase.html#a5">getTypeId</a>().isOfType(SoGroup::getClassTypeId())) {
      <a class="code" href="classSoGroup.html">SoGroup</a> * group = (<a class="code" href="classSoGroup.html">SoGroup</a> *)node;  <span class="comment">// safe downward cast, knows the type</span>
<span class="comment"></span>    }
  }
</div></pre><p>
For application programmers wanting to extend the library with new nodes, engines, nodekits, draggers or others: this method needs to be overridden in <em>all</em> subclasses. This is typically done as part of setting up the full type system for extension classes, which is usually accomplished by using the pre-defined macros available through for instance Inventor/nodes/SoSubNode.h (SO_NODE_INIT_CLASS and SO_NODE_CONSTRUCTOR for node classes), Inventor/engines/SoSubEngine.h (for engine classes) and so on.<p>
For more information on writing Coin extensions, see the class documentation of the toplevel superclasses for the various class groups. 
<p>
Reimplemented from <a class="el" href="classSoVRMLGeometry.html#a0">SoVRMLGeometry</a>.    </td>
  </tr>
</table>
<a class="anchor" name="f0" doxytag="SoVRMLExtrusion::getFieldDataPtr" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> const <a class="el" href="classSoFieldData.html">SoFieldData</a> ** SoVRMLExtrusion::getFieldDataPtr           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static, protected]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em> 
<p>
Reimplemented from <a class="el" href="classSoVRMLGeometry.html#f0">SoVRMLGeometry</a>.    </td>
  </tr>
</table>
<a class="anchor" name="b0" doxytag="SoVRMLExtrusion::getFieldData" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> const <a class="el" href="classSoFieldData.html">SoFieldData</a> * SoVRMLExtrusion::getFieldData           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns a pointer to the class-wide field data storage object for this instance. If no fields are present, returns <code>NULL</code>. 
<p>
Reimplemented from <a class="el" href="classSoVRMLGeometry.html#b0">SoVRMLGeometry</a>.    </td>
  </tr>
</table>
<a class="anchor" name="e1" doxytag="SoVRMLExtrusion::initClass" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoVRMLExtrusion::initClass           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets up initialization for data common to all instances of this class, like submitting necessary information to the Coin type system. 
<p>
Reimplemented from <a class="el" href="classSoVRMLGeometry.html#e1">SoVRMLGeometry</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a2" doxytag="SoVRMLExtrusion::GLRender" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoVRMLExtrusion::GLRender           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classSoGLRenderAction.html">SoGLRenderAction</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>action</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Action method for the <a class="el" href="classSoGLRenderAction.html">SoGLRenderAction</a>.<p>
This is called during rendering traversals. Nodes influencing the rendering state in any way or who wants to throw geometry primitives at OpenGL overrides this method. 
<p>
Reimplemented from <a class="el" href="classSoShape.html#a4">SoShape</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a3" doxytag="SoVRMLExtrusion::getPrimitiveCount" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoVRMLExtrusion::getPrimitiveCount           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classSoGetPrimitiveCountAction.html">SoGetPrimitiveCountAction</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>action</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Action method for the <a class="el" href="classSoGetPrimitiveCountAction.html">SoGetPrimitiveCountAction</a>.<p>
Calculates the number of triangle, line segment and point primitives for the node and adds these to the counters of the <em>action</em>.<p>
Nodes influencing how geometry nodes calculates their primitive count also overrides this method to change the relevant state variables. 
<p>
Reimplemented from <a class="el" href="classSoShape.html#a8">SoShape</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a4" doxytag="SoVRMLExtrusion::computeBBox" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoVRMLExtrusion::computeBBox           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classSoAction.html">SoAction</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>action</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classSbBox3f.html">SbBox3f</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>box</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classSbVec3f.html">SbVec3f</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>center</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Implemented by <a class="el" href="classSoShape.html">SoShape</a> subclasses to let the <a class="el" href="classSoShape.html">SoShape</a> superclass know the exact size and weighted center point of the shape's bounding box.<p>
The bounding box and center point should be calculated and returned in the local coordinate system.<p>
The method implements action behavior for shape nodes for <a class="el" href="classSoGetBoundingBoxAction.html">SoGetBoundingBoxAction</a>. It is invoked from SoShape::getBoundingBox(). (Subclasses should <em>not</em> override SoNode::getBoundingBox().)<p>
The <em>box</em> parameter sent in is guaranteed to be an empty box, while <em>center</em> is undefined upon function entry. 
<p>
Implements <a class="el" href="classSoShape.html#a7">SoShape</a>.    </td>
  </tr>
</table>
<a class="anchor" name="b2" doxytag="SoVRMLExtrusion::notify" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoVRMLExtrusion::notify           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classSoNotList.html">SoNotList</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>list</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [protected, virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Notifies all auditors for this instance when changes are made. 
<p>
Reimplemented from <a class="el" href="classSoVRMLGeometry.html#b6">SoVRMLGeometry</a>.    </td>
  </tr>
</table>
<a class="anchor" name="b3" doxytag="SoVRMLExtrusion::generatePrimitives" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoVRMLExtrusion::generatePrimitives           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classSoAction.html">SoAction</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>action</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [protected, virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The method implements action behavior for shape nodes for <a class="el" href="classSoCallbackAction.html">SoCallbackAction</a>. It is invoked from SoShape::callback(). (Subclasses should <em>not</em> override SoNode::callback().)<p>
The subclass implementations uses the convenience methods SoShape::beginShape(), SoShape::shapeVertex(), and <a class="el" href="classSoShape.html#b21">SoShape::endShape()</a>, with <a class="el" href="classSoDetail.html">SoDetail</a> instances, to pass the primitives making up the shape back to the caller. 
<p>
Implements <a class="el" href="classSoShape.html#b4">SoShape</a>.    </td>
  </tr>
</table>
<a class="anchor" name="b4" doxytag="SoVRMLExtrusion::createTriangleDetail" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classSoDetail.html">SoDetail</a> * SoVRMLExtrusion::createTriangleDetail           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classSoRayPickAction.html">SoRayPickAction</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>action</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>const <a class="el" href="classSoPrimitiveVertex.html">SoPrimitiveVertex</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>v1</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>const <a class="el" href="classSoPrimitiveVertex.html">SoPrimitiveVertex</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>v2</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>const <a class="el" href="classSoPrimitiveVertex.html">SoPrimitiveVertex</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>v3</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classSoPickedPoint.html">SoPickedPoint</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>pp</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [protected, virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Will create triangle detail for a <a class="el" href="classSoPickedPoint.html">SoPickedPoint</a>. This method will only be called internally, when generatePrimitives() is used for picking (SoShape::rayPick() is not overridden).<p>
This method returns <code>NULL</code> in Open Inventor, and subclasses will need to override this method to create details for a <a class="el" href="classSoPickedPoint.html">SoPickedPoint</a>.<p>
This is not necessary with Coin. Of course, if you choose to override it, it will work in the same way as Open Inventor.<p>
For this to work, you must supply a face or line detail when generating primitives. If you supply <code>NULL</code> for the detail argument in SoShape::beginShape(), you'll have to override this method. 
<p>
Reimplemented from <a class="el" href="classSoShape.html#b13">SoShape</a>.    </td>
  </tr>
</table>
<hr>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="SoVRMLExtrusion_8h-source.html">SoVRMLExtrusion.h</a><li>Extrusion.cpp</ul>
<hr noshade>
<p align="right">Copyright &copy 1998-2004 by <a href="http://www.sim.no">Systems in Motion AS</a>. All rights reserved.</p>
<address style="align: right;"><small>
Generated on Mon Oct 18 01:26:24 2004 for Coin by <a href="http://www.doxygen.org/index.html">Doxygen.</a> 1.3.7</small></address>
</body>
</html>
