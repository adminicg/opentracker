<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SbTesselator class Reference</title>
<link href="stylesheet.css" rel="stylesheet" type="text/css">
</head><body><table width="100%">
<tr>
  <td>
    <img src="Coin_logo.png" alt="Coin Logo">
  </td>
  <td align="right">
    <a href="http://www.sim.no">http://www.sim.no</a><br>
    <a href="http://www.coin3d.org/">http://www.coin3d.org</a>
  </td>
</tr>
</table>
<hr noshade>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>SbTesselator Class Reference<br>
<small>
[<a class="el" href="group__base.html">Base classes</a>]</small>
</h1><code>#include &lt;<a class="el" href="SbTesselator_8h-source.html">Inventor/SbTesselator.h</a>&gt;</code>
<p>
<a href="classSbTesselator-members.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>
The SbTesselator class is used to tessellate polygons into triangles. 
<p>
SbTesselator is used within Coin to split polygons into triangles. It handles concave polygons, does Delaunay triangulation and avoids generating self-intersecting triangles.<p>
Here's a simple example which shows how to tessellate a quad polygon with corners in &lt;0, 0, 0&gt;, &lt;1, 0, 0&gt;, &lt;1, 1, 0&gt; and &lt;0, 1, 0&gt;.<p>
<pre><div class="fragment">  <span class="comment">// Callback function for the tessellator. Called once for each</span>
  <span class="comment">// generated triangle with the vertices.</span>
  <span class="keyword">static</span> <span class="keywordtype">void</span>
  tess_cb(<span class="keywordtype">void</span> * v0, <span class="keywordtype">void</span> * v1, <span class="keywordtype">void</span> * v2, <span class="keywordtype">void</span> * cbdata)
  {
    <a class="code" href="classSbVec3f.html">SbVec3f</a> * vtx0 = (<a class="code" href="classSbVec3f.html">SbVec3f</a> *)v0;
    <a class="code" href="classSbVec3f.html">SbVec3f</a> * vtx1 = (<a class="code" href="classSbVec3f.html">SbVec3f</a> *)v1;
    <a class="code" href="classSbVec3f.html">SbVec3f</a> * vtx2 = (<a class="code" href="classSbVec3f.html">SbVec3f</a> *)v2;
    (<span class="keywordtype">void</span>) fprintf(stdout, <span class="stringliteral">"triangle: &lt;%f, %f, %f&gt; &lt;%f, %f, %f&gt; &lt;%f, %f, %f&gt;\n"</span>,
      (*vtx0)[0], (*vtx0)[1], (*vtx0)[2],
      (*vtx1)[0], (*vtx1)[1], (*vtx1)[2],
      (*vtx2)[0], (*vtx2)[1], (*vtx2)[2]);

    <span class="comment">// Do stuff with triangle here.</span>
  }

  <span class="keyword">static</span> <a class="code" href="classSbVec3f.html">SbVec3f</a> vertices[] = {
    <a class="code" href="classSbVec3f.html">SbVec3f</a>(1, 0, 0), <a class="code" href="classSbVec3f.html">SbVec3f</a>(1, 1, 0),
    <a class="code" href="classSbVec3f.html">SbVec3f</a>(0, 1, 0), <a class="code" href="classSbVec3f.html">SbVec3f</a>(0, 0, 0)
  };

  <a class="code" href="classSbTesselator.html">SbTesselator</a> mytessellator(tess_cb, NULL);
  mytessellator.<a class="code" href="classSbTesselator.html#a2">beginPolygon</a>();
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i &lt; 4; i++)
    mytessellator.<a class="code" href="classSbTesselator.html#a3">addVertex</a>(vertices[i], &amp;vertices[i]);
  mytessellator.<a class="code" href="classSbTesselator.html#a4">endPolygon</a>();
</div></pre><p>
The call to <a class="el" href="classSbTesselator.html#a4">SbTesselator::endPolygon()</a> triggers the SbTesselator to spring into action, calling the tess_cb() function for each triangle it generates.<p>
The reason we use 2 arguments to SbTesselator::addVertex() and passes void pointers for the vertices to the callback function is to make it possible to have more complex structures than just the coordinates themselves (as in the example above), like material information, lighting information or whatever other attributes your vertices have.<p>
This class is not part of the original Open Inventor API.<p>
(Another option for tessellating polygons is the tessellator of the GLU library. It has some features not part of SbTesselator (like handling hulls), but the GLU library is known to have bugs in various implementations and doesn't do Delaunay triangulation.) 
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSbTesselator.html#a0">SbTesselator</a> (void(*callback)(void *v0, void *v1, void *v2, void *data)=NULL, void *userdata=NULL)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSbTesselator.html#a1">~SbTesselator</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSbTesselator.html#a2">beginPolygon</a> (SbBool keepVertices=0, const <a class="el" href="classSbVec3f.html">SbVec3f</a> &amp;normal=<a class="el" href="classSbVec3f.html">SbVec3f</a>(0.0f, 0.0f, 0.0f))</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSbTesselator.html#a3">addVertex</a> (const <a class="el" href="classSbVec3f.html">SbVec3f</a> &amp;v, void *data)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSbTesselator.html#a4">endPolygon</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSbTesselator.html#a5">setCallback</a> (void(*callback)(void *v0, void *v1, void *v2, void *data), void *data)</td></tr>

</table>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="a0" doxytag="SbTesselator::SbTesselator" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> SbTesselator::SbTesselator           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void(*&nbsp;</td>
          <td class="mdname" nowrap> <em>callbackptr</em>)(void *v0, void *v1, void *v2, void *data) = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>userdata</em> = <code>NULL</code></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initializes a tessellator. The <em>callback</em> argument specifies a function which will be called for each triangle returned by the tessellator. The callback function will get three pointers to each vertex and the <em>userdata</em> pointer. The vertex pointers are specified in the SbTesselator::addVertex() method.     </td>
  </tr>
</table>
<a class="anchor" name="a1" doxytag="SbTesselator::~SbTesselator" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> SbTesselator::~<a class="el" href="classSbTesselator.html">SbTesselator</a>           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Destructor.     </td>
  </tr>
</table>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="a2" doxytag="SbTesselator::beginPolygon" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SbTesselator::beginPolygon           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">SbBool&nbsp;</td>
          <td class="mdname" nowrap> <em>keepVerts</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>const <a class="el" href="classSbVec3f.html">SbVec3f</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>normal</em> = <code><a class="el" href="classSbVec3f.html">SbVec3f</a>(0.0f,&nbsp;0.0f,&nbsp;0.0f)</code></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initializes new polygon.<p>
You can explicitly set the polygon normal if you know what it is. Otherwise it will be calculated internally.<p>
If <em>keepVerts</em> is <code>TRUE</code>, all vertices will be included in the returned triangles, even though this might lead to triangles without area.     </td>
  </tr>
</table>
<a class="anchor" name="a3" doxytag="SbTesselator::addVertex" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SbTesselator::addVertex           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classSbVec3f.html">SbVec3f</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>data</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Adds a new vertex to the polygon. <em>data</em> will be returned as a vertex in the callback-function.     </td>
  </tr>
</table>
<a class="anchor" name="a4" doxytag="SbTesselator::endPolygon" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SbTesselator::endPolygon           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Signals the tessellator to begin tessellating. The callback function specified in the constructor (or set using the SbTesselator::setCallback() method) will be called for each triangle before returning.     </td>
  </tr>
</table>
<a class="anchor" name="a5" doxytag="SbTesselator::setCallback" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SbTesselator::setCallback           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void(*&nbsp;</td>
          <td class="mdname" nowrap> <em>callbackptr</em>)(void *v0, void *v1, void *v2, void *data), </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>data</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets the callback function for this tessellator.     </td>
  </tr>
</table>
<hr>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="SbTesselator_8h-source.html">SbTesselator.h</a><li>SbTesselator.cpp</ul>
<hr noshade>
<p align="right">Copyright &copy 1998-2004 by <a href="http://www.sim.no">Systems in Motion AS</a>. All rights reserved.</p>
<address style="align: right;"><small>
Generated on Mon Oct 18 01:25:49 2004 for Coin by <a href="http://www.doxygen.org/index.html">Doxygen.</a> 1.3.7</small></address>
</body>
</html>
