<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SoType class Reference</title>
<link href="stylesheet.css" rel="stylesheet" type="text/css">
</head><body><table width="100%">
<tr>
  <td>
    <img src="Coin_logo.png" alt="Coin Logo">
  </td>
  <td align="right">
    <a href="http://www.sim.no">http://www.sim.no</a><br>
    <a href="http://www.coin3d.org/">http://www.coin3d.org</a>
  </td>
</tr>
</table>
<hr noshade>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>SoType Class Reference<br>
<small>
[<a class="el" href="group__general.html">General classes</a>]</small>
</h1><code>#include &lt;<a class="el" href="SoType_8h-source.html">Inventor/SoType.h</a>&gt;</code>
<p>
<a href="classSoType-members.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>
The SoType class is the basis for the run-time type system in Coin. 
<p>
Many of the classes in the Coin library must have their type information registered before any instances are created (including, but not limited to: engines, nodes, fields, actions, nodekits and manipulators). The use of SoType to store this information provides lots of various functionality for working with class hierarchies, comparing class types, instantiating objects from classnames, etc etc.<p>
It is for instance possible to do things like this:<p>
<pre><div class="fragment">  <span class="keywordtype">void</span> cleanLens(<a class="code" href="classSoNode.html">SoNode</a> * anode)
  {
    assert(anode-&gt;<a class="code" href="classSoBase.html#a5">getTypeId</a>().<a class="code" href="classSoType.html#a2">isDerivedFrom</a>(SoCamera::getClassTypeId()));

    <span class="keywordflow">if</span> (anode-&gt;<a class="code" href="classSoBase.html#a5">getTypeId</a>() == <a class="code" href="classSoPerspectiveCamera.html#e0">SoPerspectiveCamera::getClassTypeId</a>()) {
      <span class="comment">// do something..</span>
    }
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (anode-&gt;<a class="code" href="classSoBase.html#a5">getTypeId</a>() == <a class="code" href="classSoOrthographicCamera.html#e0">SoOrthographicCamera::getClassTypeId</a>()) {
      <span class="comment">// do something..</span>
    }
    <span class="keywordflow">else</span> {
      <a class="code" href="classSoDebugError.html#e5">SoDebugError::postWarning</a>(<span class="stringliteral">"cleanLens"</span>, <span class="stringliteral">"Unknown camera type %s!\n"</span>,
                                anode-&gt;<a class="code" href="classSoBase.html#a5">getTypeId</a>().<a class="code" href="classSoType.html#a0">getName</a>());
    }
  }
</div></pre><p>
A notable feature of the SoType class is that it is only 16 bits long and therefore should be passed around by value for efficiency reasons.<p>
One important note about the use of SoType to register class information: super classes must be registered before any of their derived classes are.<p>
See also <a class="el" href="dynload_overview.html">Dynamic Loading of Extension Nodes</a> for some additional SoType-related information. 
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>typedef void *(*&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoType.html#w0">instantiationMethod</a> )(void)</td></tr>

<tr><td colspan=2><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="classSbName.html">SbName</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoType.html#a0">getName</a> (void) const</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>const <a class="el" href="classSoType.html">SoType</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoType.html#a1">getParent</a> (void) const</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>SbBool&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoType.html#a2">isDerivedFrom</a> (const <a class="el" href="classSoType.html">SoType</a> type) const</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>SbBool&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoType.html#a3">canCreateInstance</a> (void) const</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoType.html#a4">createInstance</a> (void) const</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>uint16_t&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoType.html#a5">getData</a> (void) const</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>int16_t&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoType.html#a6">getKey</a> (void) const</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>SbBool&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoType.html#a7">operator==</a> (const <a class="el" href="classSoType.html">SoType</a> type) const</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>SbBool&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoType.html#a8">operator!=</a> (const <a class="el" href="classSoType.html">SoType</a> type) const</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>SbBool&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoType.html#a9">operator&lt;</a> (const <a class="el" href="classSoType.html">SoType</a> type) const</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>SbBool&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoType.html#a10">operator&lt;=</a> (const <a class="el" href="classSoType.html">SoType</a> type) const</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>SbBool&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoType.html#a11">operator&gt;=</a> (const <a class="el" href="classSoType.html">SoType</a> type) const</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>SbBool&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoType.html#a12">operator&gt;</a> (const <a class="el" href="classSoType.html">SoType</a> type) const</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>SbBool&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoType.html#a13">isBad</a> (void) const</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoType.html#a14">makeInternal</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>SbBool&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoType.html#a15">isInternal</a> (void) const</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="classSoType.html#w0">instantiationMethod</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoType.html#a16">getInstantiationMethod</a> (void) const</td></tr>

<tr><td colspan=2><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="classSoType.html">SoType</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoType.html#e0">fromName</a> (const <a class="el" href="classSbName.html">SbName</a> name)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoType.html#e1">getAllDerivedFrom</a> (const <a class="el" href="classSoType.html">SoType</a> type, <a class="el" href="classSoTypeList.html">SoTypeList</a> &amp;list)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>const <a class="el" href="classSoType.html">SoType</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoType.html#e2">createType</a> (const <a class="el" href="classSoType.html">SoType</a> parent, const <a class="el" href="classSbName.html">SbName</a> name, const <a class="el" href="classSoType.html#w0">instantiationMethod</a> method=(<a class="el" href="classSoType.html#w0">instantiationMethod</a>) NULL, const uint16_t data=0)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>const <a class="el" href="classSoType.html">SoType</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoType.html#e3">overrideType</a> (const <a class="el" href="classSoType.html">SoType</a> originalType, const <a class="el" href="classSoType.html#w0">instantiationMethod</a> method=(<a class="el" href="classSoType.html#w0">instantiationMethod</a>) NULL)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoType.html#e4">init</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="classSoType.html">SoType</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoType.html#e5">fromKey</a> (uint16_t key)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="classSoType.html">SoType</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoType.html#e6">badType</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoType.html#e7">getNumTypes</a> (void)</td></tr>

</table>
<hr><h2>Member Typedef Documentation</h2>
<a class="anchor" name="w0" doxytag="SoType::instantiationMethod" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classSoType.html#w0">SoType::instantiationMethod</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This is a convenience typedef for the function signature of a typed class' instantiation method. It is an extension on the original Inventor API. Mostly only useful for internal purposes.<p>
An instantation method will take no arguments and returns a void-pointer to a newly allocated and initialized object of the class type.     </td>
  </tr>
</table>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="e0" doxytag="SoType::fromName" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classSoType.html">SoType</a> SoType::fromName           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classSbName.html">SbName</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>name</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This static function returns the SoType object associated with name <em>name</em>.<p>
Type objects for builtin types can be retreived by name both with and without the "So" prefix. For dynamically loadable extension nodes, the name given to this function must match exactly.<p>
If no node type with the given name has been initialized, a dynamically loadable extension node with the given name is searched for. If one is found, it is loaded and initialized, and the SoType object for the newly initialized class type returned. If no module is found, or the initialization of the module fails, <a class="el" href="classSoType.html#e6">SoType::badType()</a> is returned.<p>
Support for dynamically loadable extension nodes varies from platform to platform, and from compiler suite to compiler suite.<p>
So far code built with the following compilers are supported: GNU GCC v2, GNU GCC v3, Microsoft Visual C++ v6 (and probably v7, not tested), SGI MIPSPro v7.<p>
Extensions built with compilers that are known to be binary compatible with the above compilers are also supported, such as e.g. the Intel x86 compiler compatible with MSVC++.<p>
To support dynamic loading for other compilers, we need to know how the compiler mangles the "static void classname::initClass(void)" symbol. If your compiler is not supported, tell us at <code><a href="mailto:coin-support@coin3d.org">coin-support@coin3d.org</a></code> which it is and send us the output of a symbol-dump on the shared object. Typically you can do<p>
<pre><div class="fragment">  $ nm &lt;Node&gt;.so | grep initClass
</div></pre><p>
to find the relevant mangled symbol.     </td>
  </tr>
</table>
<a class="anchor" name="a0" doxytag="SoType::getName" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classSbName.html">SbName</a> SoType::getName           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This method returns the name of the SoBase-derived class type the SoType object is configured for.     </td>
  </tr>
</table>
<a class="anchor" name="a1" doxytag="SoType::getParent" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> const <a class="el" href="classSoType.html">SoType</a> SoType::getParent           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This method returns the SoType type for the parent class of the SoBase-derived class the SoType object is configured for.     </td>
  </tr>
</table>
<a class="anchor" name="a2" doxytag="SoType::isDerivedFrom" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> SbBool SoType::isDerivedFrom           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classSoType.html">SoType</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>parent</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This method returns <code>TRUE</code> if the given type is derived from (or <em>is</em>) the <em>parent</em> type, and <code>FALSE</code> otherwise.     </td>
  </tr>
</table>
<a class="anchor" name="e1" doxytag="SoType::getAllDerivedFrom" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int SoType::getAllDerivedFrom           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classSoType.html">SoType</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classSoTypeList.html">SoTypeList</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>list</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This method appends all the class types derived from <em>type</em> to <em>list</em>, and returns the number of types added to the list. Internal types are not included in the list, nor are they counted.<p>
<em>type</em> itself is also added to the list, as a type is seen as a derivation of its own type.<p>
NB: do not write code which depends in any way on the order of the elements returned in <em>list</em>.     </td>
  </tr>
</table>
<a class="anchor" name="a3" doxytag="SoType::canCreateInstance" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> SbBool SoType::canCreateInstance           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This method returns <code>FALSE</code> for abstract base classes, and <code>TRUE</code> for class types that can be instantiated.     </td>
  </tr>
</table>
<a class="anchor" name="a4" doxytag="SoType::createInstance" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void * SoType::createInstance           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This method instantiates an object of the current type.<p>
For types that can not be instantiated, <code>NULL</code> is returned.<p>
<b>Note that if the Coin library has been built as a DLL under Microsoft Windows and you use this method from application code, you <em>must</em> make sure that both the Coin DLL and the application executable is using the same instance of a C Run-Time (CRT) library. Otherwise, you <em>will</em> get memory heap corruption upon deallocating the returned instances, eventually leading to mysterious crashes.</b><p>
This is not harmful if you only call <a class="el" href="classSoType.html#a4">SoType::createInstance()</a> on types for reference counted class-types, though. These include all nodes, engines, paths, nodekits, draggers and manipulators.     </td>
  </tr>
</table>
<a class="anchor" name="a5" doxytag="SoType::getData" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> uint16_t SoType::getData           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This method returns a type specific data variable.     </td>
  </tr>
</table>
<a class="anchor" name="a6" doxytag="SoType::getKey" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int16_t SoType::getKey           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This method returns the type's index in the internal typelist.     </td>
  </tr>
</table>
<a class="anchor" name="a7" doxytag="SoType::operator==" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> SbBool SoType::operator==           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classSoType.html">SoType</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>type</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Check type equality.     </td>
  </tr>
</table>
<a class="anchor" name="a8" doxytag="SoType::operator!=" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> SbBool SoType::operator!=           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classSoType.html">SoType</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>type</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Check type inequality.     </td>
  </tr>
</table>
<a class="anchor" name="a9" doxytag="SoType::operator<" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> SbBool SoType::operator&lt;           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classSoType.html">SoType</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>type</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Comparison operator for sorting type data according to some internal criterion.     </td>
  </tr>
</table>
<a class="anchor" name="a10" doxytag="SoType::operator<=" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> SbBool SoType::operator&lt;=           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classSoType.html">SoType</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>type</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Comparison operator for sorting type data according to some internal criterion.     </td>
  </tr>
</table>
<a class="anchor" name="a11" doxytag="SoType::operator>=" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> SbBool SoType::operator&gt;=           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classSoType.html">SoType</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>type</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Comparison operator for sorting type data according to some internal criterion.     </td>
  </tr>
</table>
<a class="anchor" name="a12" doxytag="SoType::operator>" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> SbBool SoType::operator&gt;           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classSoType.html">SoType</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>type</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Comparison operator for sorting type data according to some internal criterion.     </td>
  </tr>
</table>
<a class="anchor" name="e2" doxytag="SoType::createType" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> const <a class="el" href="classSoType.html">SoType</a> SoType::createType           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classSoType.html">SoType</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>parent</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>const <a class="el" href="classSbName.html">SbName</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>const <a class="el" href="classSoType.html#w0">instantiationMethod</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>method</em> = <code>(<a class="el" href="classSoType.html#w0">instantiationMethod</a>)&nbsp;NULL</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>const uint16_t&nbsp;</td>
          <td class="mdname" nowrap> <em>data</em> = <code>0</code></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This method creates and registers a new class type.<p>
Classes that do not inherit any other class should use <a class="el" href="classSoType.html#e6">SoType::badType()</a> for the first argument. Abstract classes should use <code>NULL</code> for the <em>method</em> argument.<p>
The value passed in for the <em>data</em> parameter can be retrieved with <a class="el" href="classSoType.html#a5">SoType::getData()</a>.     </td>
  </tr>
</table>
<a class="anchor" name="e3" doxytag="SoType::overrideType" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> const <a class="el" href="classSoType.html">SoType</a> SoType::overrideType           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classSoType.html">SoType</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>originalType</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>const <a class="el" href="classSoType.html#w0">instantiationMethod</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>method</em> = <code>(<a class="el" href="classSoType.html#w0">instantiationMethod</a>)&nbsp;NULL</code></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This method makes a new class's instantiation method override the instantiation method of an existing class.<p>
The new type should be a C++ subclass of the original class type, but this won't be checked though.<p>
If <code>NULL</code> is passed as the second argument, the type will be considered uninstantiable -- it does not revert the configuration to the default setting as one might think.<p>
Here's a <em>complete</em> code examples which shows how to fully override a built-in Coin node class, so that a) your application-specific extension class gets instantiated instead of the built-in class upon scenegraph import, and b) it gets written out properly upon export:<p>
<pre><div class="fragment"><span class="preprocessor">  #include &lt;Inventor/SoDB.h&gt;</span>
<span class="preprocessor">  #include &lt;Inventor/actions/SoWriteAction.h&gt;</span>
<span class="preprocessor">  #include &lt;Inventor/errors/SoDebugError.h&gt;</span>
<span class="preprocessor">  #include &lt;Inventor/nodes/SoSeparator.h&gt;</span>
<span class="preprocessor">  #include &lt;Inventor/nodes/SoWWWInline.h&gt;</span>


  <span class="keyword">class </span>MyWWWInline : <span class="keyword">public</span> SoWWWInline {
    SO_NODE_HEADER(MyWWWInline);

  <span class="keyword">public</span>:
    <span class="keyword">static</span> <span class="keywordtype">void</span> initClass(<span class="keywordtype">void</span>);
    MyWWWInline(<span class="keywordtype">void</span>);

  <span class="keyword">protected</span>:
    <span class="keyword">virtual</span> ~MyWWWInline();
    <span class="keyword">virtual</span> SbBool readInstance(<a class="code" href="classSoInput.html">SoInput</a> * in, <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> flags);
    <span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keywordtype">char</span> * getFileFormatName(<span class="keywordtype">void</span>) const;
  };

  SO_NODE_SOURCE(MyWWWInline);

  MyWWWInline::MyWWWInline(<span class="keywordtype">void</span>)
  {
    SO_NODE_CONSTRUCTOR(MyWWWInline);

    <span class="comment">// Fool the library to believe this is an internal class, so it gets</span>
    <span class="comment">// written out in the same manner as the built-in classes, instead</span>
    <span class="comment">// of as en extension class. There are slight differences, which you</span>
    <span class="comment">// want to avoid when overriding a class like we do with MyWWWInline</span>
    <span class="comment">// vs SoWWWInline here.</span>
    this-&gt;isBuiltIn = TRUE;
  }

  MyWWWInline::~MyWWWInline()
  {
  }

  <span class="keywordtype">void</span>
  <a class="code" href="classSoWWWInline.html#e1">MyWWWInline::initClass</a>(<span class="keywordtype">void</span>)
  {
    SO_NODE_INIT_CLASS(MyWWWInline, SoWWWInline, <span class="stringliteral">"SoWWWInline"</span>);

    <span class="comment">// Override instantiation method, so we get MyWWWInline instead of</span>
    <span class="comment">// SoWWWInline instances upon scenegraph import.</span>
    (<span class="keywordtype">void</span>)<a class="code" href="classSoType.html#e3">SoType::overrideType</a>(SoWWWInline::getClassTypeId(),
                               MyWWWInline::createInstance);
  }

  <span class="comment">// Override SoBase::getFileFormatName() to make node get written as</span>
  <span class="comment">// "WWWInline" instead of "MyWWWInline".</span>
  <span class="keyword">const</span> <span class="keywordtype">char</span> *
  <a class="code" href="classSoBase.html#b6">MyWWWInline::getFileFormatName</a>(<span class="keywordtype">void</span>)<span class="keyword"> const</span>
<span class="keyword">  </span>{
    <span class="keywordflow">return</span> <span class="stringliteral">"WWWInline"</span>;
  }

  SbBool
  MyWWWInline::readInstance(<a class="code" href="classSoInput.html">SoInput</a> * in, <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> flags)
  {
    <a class="code" href="classSoDebugError.html#e6">SoDebugError::postInfo</a>(<span class="stringliteral">"MyWWWInline::readInstance"</span>, <span class="stringliteral">"hepp"</span>);
    <span class="keywordflow">return</span> <a class="code" href="classSoWWWInline.html#b3">SoWWWInline::readInstance</a>(in, flags);
  }


  <span class="keywordtype">int</span>
  main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> ** argv)
  {
    <a class="code" href="classSoDB.html#e0">SoDB::init</a>();
    <a class="code" href="classSoWWWInline.html#e1">MyWWWInline::initClass</a>();

    <span class="keyword">const</span> <span class="keywordtype">char</span> * ivscene =
      <span class="stringliteral">"#Inventor V2.1 ascii\n\n"</span>
      <span class="stringliteral">"Separator {"</span>
      <span class="stringliteral">"  WWWInline { }"</span>
      <span class="stringliteral">"}"</span>;

    <a class="code" href="classSoInput.html">SoInput</a> in;
    in.<a class="code" href="classSoInput.html#a18">setBuffer</a>((<span class="keywordtype">void</span> *)ivscene, strlen(ivscene));
    SoSeparator * root = <a class="code" href="classSoDB.html#e6">SoDB::readAll</a>(&amp;in);
    root-&gt;<a class="code" href="classSoBase.html#a0">ref</a>();

    <a class="code" href="classSoOutput.html">SoOutput</a> out;
    <a class="code" href="classSoWriteAction.html">SoWriteAction</a> wa(&amp;out);
    wa.<a class="code" href="classSoAction.html#a3">apply</a>(root);
    root-&gt;<a class="code" href="classSoBase.html#a1">unref</a>();

    <span class="keywordflow">return</span> 0;
  }
</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="e4" doxytag="SoType::init" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoType::init           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This static method initializes the type system.     </td>
  </tr>
</table>
<a class="anchor" name="e5" doxytag="SoType::fromKey" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classSoType.html">SoType</a> SoType::fromKey           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">uint16_t&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>key</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Find and return a type from the given key ID.     </td>
  </tr>
</table>
<a class="anchor" name="e6" doxytag="SoType::badType" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classSoType.html">SoType</a> SoType::badType           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This method returns an illegal type, useful for returning errors.<p>
<dl compact><dt><b>See also:</b></dt><dd>SbBool <a class="el" href="classSoType.html#a13">SoType::isBad() const</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a13" doxytag="SoType::isBad" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> SbBool SoType::isBad           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This method returns TRUE if the SoType object represents an illegal class type.     </td>
  </tr>
</table>
<a class="anchor" name="a14" doxytag="SoType::makeInternal" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoType::makeInternal           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This method turns the specific type into an internal type.     </td>
  </tr>
</table>
<a class="anchor" name="a15" doxytag="SoType::isInternal" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> SbBool SoType::isInternal           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function returns TRUE if the type is an internal type.     </td>
  </tr>
</table>
<a class="anchor" name="e7" doxytag="SoType::getNumTypes" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int SoType::getNumTypes           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function returns the number of types registered in the run-time type system.     </td>
  </tr>
</table>
<a class="anchor" name="a16" doxytag="SoType::getInstantiationMethod" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classSoType.html#w0">SoType::instantiationMethod</a> SoType::getInstantiationMethod           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns a pointer to the method used to instantiate objects of the given type.<p>
This function is an extension for Coin, and it is not available in the original SGI Open Inventor v2.1 API.<p>
<dl compact><dt><b>Since:</b></dt><dd>Coin 2.0 </dd></dl>
    </td>
  </tr>
</table>
<hr>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="SoType_8h-source.html">SoType.h</a><li>SoType.cpp</ul>
<hr noshade>
<p align="right">Copyright &copy 1998-2004 by <a href="http://www.sim.no">Systems in Motion AS</a>. All rights reserved.</p>
<address style="align: right;"><small>
Generated on Mon Oct 18 01:26:09 2004 for Coin by <a href="http://www.doxygen.org/index.html">Doxygen.</a> 1.3.7</small></address>
</body>
</html>
