<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SoOutput class Reference</title>
<link href="stylesheet.css" rel="stylesheet" type="text/css">
</head><body><table width="100%">
<tr>
  <td>
    <img src="Coin_logo.png" alt="Coin Logo">
  </td>
  <td align="right">
    <a href="http://www.sim.no">http://www.sim.no</a><br>
    <a href="http://www.coin3d.org/">http://www.coin3d.org</a>
  </td>
</tr>
</table>
<hr noshade>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>SoOutput Class Reference<br>
<small>
[<a class="el" href="group__general.html">General classes</a>]</small>
</h1><code>#include &lt;<a class="el" href="SoOutput_8h-source.html">Inventor/SoOutput.h</a>&gt;</code>
<p>
<a href="classSoOutput-members.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>
The SoOutput class is an abstraction of an output stream. 
<p>
SoOutput offers the ability to write basic types to a file or a memory buffer in either ASCII or binary format.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSoInput.html">SoInput</a> </dd></dl>

<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>enum &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoOutput.html#w4">Stage</a> { <a class="el" href="classSoOutput.html#w4w0">COUNT_REFS</a>, 
<a class="el" href="classSoOutput.html#w4w1">WRITE</a>
 }</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>enum &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoOutput.html#w5">Annotations</a> { <a class="el" href="classSoOutput.html#w5w2">ADDRESSES</a> =  0x01, 
<a class="el" href="classSoOutput.html#w5w3">REF_COUNTS</a> =  0x02
 }</td></tr>

<tr><td colspan=2><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoOutput.html#a0">SoOutput</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoOutput.html#a1">SoOutput</a> (<a class="el" href="classSoOutput.html">SoOutput</a> *dictOut)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoOutput.html#a2">~SoOutput</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoOutput.html#a3">setFilePointer</a> (FILE *newFP)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual FILE *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoOutput.html#a4">getFilePointer</a> (void) const</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual SbBool&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoOutput.html#a5">openFile</a> (const char *const fileName)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoOutput.html#a6">closeFile</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>SbBool&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoOutput.html#a7">setCompression</a> (const <a class="el" href="classSbName.html">SbName</a> &amp;compmethod, const float level=0.5f)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoOutput.html#a8">setBuffer</a> (void *bufPointer, size_t initSize, SoOutputReallocCB *reallocFunc, int32_t offset=0)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual SbBool&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoOutput.html#a9">getBuffer</a> (void *&amp;bufPointer, size_t &amp;nBytes) const</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual size_t&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoOutput.html#a10">getBufferSize</a> (void) const</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoOutput.html#a11">resetBuffer</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoOutput.html#a12">setBinary</a> (const SbBool flag)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual SbBool&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoOutput.html#a13">isBinary</a> (void) const</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoOutput.html#a14">setHeaderString</a> (const <a class="el" href="classSbString.html">SbString</a> &amp;str)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoOutput.html#a15">resetHeaderString</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoOutput.html#a16">setFloatPrecision</a> (const int precision)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoOutput.html#a17">setStage</a> (<a class="el" href="classSoOutput.html#w4">Stage</a> stage)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="classSoOutput.html#w4">Stage</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoOutput.html#a18">getStage</a> (void) const</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoOutput.html#a19">incrementIndent</a> (const int levels=1)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoOutput.html#a20">decrementIndent</a> (const int levels=1)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoOutput.html#a21">write</a> (const char c)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoOutput.html#a22">write</a> (const char *s)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoOutput.html#a23">write</a> (const <a class="el" href="classSbString.html">SbString</a> &amp;s)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoOutput.html#a24">write</a> (const <a class="el" href="classSbName.html">SbName</a> &amp;n)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoOutput.html#a25">write</a> (const int i)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoOutput.html#a26">write</a> (const unsigned int i)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoOutput.html#a27">write</a> (const short s)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoOutput.html#a28">write</a> (const unsigned short s)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoOutput.html#a29">write</a> (const float f)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoOutput.html#a30">write</a> (const double d)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoOutput.html#a31">writeBinaryArray</a> (const unsigned char *c, const int length)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoOutput.html#a32">writeBinaryArray</a> (const int32_t *const l, const int length)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoOutput.html#a33">writeBinaryArray</a> (const float *const f, const int length)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoOutput.html#a34">writeBinaryArray</a> (const double *const d, const int length)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoOutput.html#a35">indent</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoOutput.html#a36">reset</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoOutput.html#a37">setCompact</a> (SbBool flag)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>SbBool&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoOutput.html#a38">isCompact</a> (void) const</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoOutput.html#a39">setAnnotation</a> (uint32_t bits)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>uint32_t&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoOutput.html#a40">getAnnotation</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoOutput.html#a41">addReference</a> (const <a class="el" href="classSoBase.html">SoBase</a> *base)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoOutput.html#a42">findReference</a> (const <a class="el" href="classSoBase.html">SoBase</a> *base) const</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoOutput.html#a43">setReference</a> (const <a class="el" href="classSoBase.html">SoBase</a> *base, int refid)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoOutput.html#a44">addDEFNode</a> (<a class="el" href="classSbName.html">SbName</a> name)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>SbBool&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoOutput.html#a45">lookupDEFNode</a> (<a class="el" href="classSbName.html">SbName</a> name)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoOutput.html#a46">removeDEFNode</a> (<a class="el" href="classSbName.html">SbName</a> name)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoOutput.html#a47">pushProto</a> (SoProto *proto)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>SoProto *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoOutput.html#a48">getCurrentProto</a> (void) const</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoOutput.html#a49">popProto</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoOutput.html#a50">addRoute</a> (<a class="el" href="classSoFieldContainer.html">SoFieldContainer</a> *from, const <a class="el" href="classSbName.html">SbName</a> &amp;fromfield, <a class="el" href="classSoFieldContainer.html">SoFieldContainer</a> *to, const <a class="el" href="classSbName.html">SbName</a> &amp;tofield)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoOutput.html#a51">resolveRoutes</a> (void)</td></tr>

<tr><td colspan=2><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>const <a class="el" href="classSbName.html">SbName</a> *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoOutput.html#e0">getAvailableCompressionMethods</a> (unsigned int &amp;num)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="classSbString.html">SbString</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoOutput.html#e1">getDefaultASCIIHeader</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="classSbString.html">SbString</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoOutput.html#e2">getDefaultBinaryHeader</a> (void)</td></tr>

<tr><td colspan=2><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>SbBool&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoOutput.html#b0">isToBuffer</a> (void) const</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>size_t&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoOutput.html#b1">bytesInBuf</a> (void) const</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>SbBool&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoOutput.html#b2">makeRoomInBuf</a> (size_t nBytes)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoOutput.html#b3">convertShort</a> (short s, char *to)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoOutput.html#b4">convertInt32</a> (int32_t l, char *to)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoOutput.html#b5">convertFloat</a> (float f, char *to)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoOutput.html#b6">convertDouble</a> (double d, char *to)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoOutput.html#b7">convertShortArray</a> (short *from, char *to, int len)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoOutput.html#b8">convertInt32Array</a> (int32_t *from, char *to, int len)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoOutput.html#b9">convertFloatArray</a> (float *from, char *to, int len)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoOutput.html#b10">convertDoubleArray</a> (double *from, char *to, int len)</td></tr>

<tr><td colspan=2><br><h2>Static Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="classSbString.html">SbString</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoOutput.html#f0">padHeader</a> (const <a class="el" href="classSbString.html">SbString</a> &amp;inString)</td></tr>

<tr><td colspan=2><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>SbBool&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoOutput.html#p0">wroteHeader</a></td></tr>

</table>
<hr><h2>Member Enumeration Documentation</h2>
<a class="anchor" name="w4" doxytag="SoOutput::Stage" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> enum <a class="el" href="classSoOutput.html#w4">SoOutput::Stage</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Enumerates the possible stages of a write operation (writing needs to be done in mutiple passes).<p>
<dl compact><dt><b>See also:</b></dt><dd>setStage(), <a class="el" href="classSoOutput.html#a18">getStage()</a> </dd></dl>
<dl compact><dt><b>Enumeration values: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="anchor" name="w4w0" doxytag="COUNT_REFS" ></a>COUNT_REFS</em>&nbsp;</td><td>
Not writing, just counting the internal references in the scene graph. </td></tr>
<tr><td valign=top><em><a class="anchor" name="w4w1" doxytag="WRITE" ></a>WRITE</em>&nbsp;</td><td>
Signifies that actual data export should take place during this pass. </td></tr>
</table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="w5" doxytag="SoOutput::Annotations" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> enum <a class="el" href="classSoOutput.html#w5">SoOutput::Annotations</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Values from this enum is used for debugging purposes to annotate the output from a write operation. <dl compact><dt><b>Enumeration values: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="anchor" name="w5w2" doxytag="ADDRESSES" ></a>ADDRESSES</em>&nbsp;</td><td>
Annotate output with pointer address information. </td></tr>
<tr><td valign=top><em><a class="anchor" name="w5w3" doxytag="REF_COUNTS" ></a>REF_COUNTS</em>&nbsp;</td><td>
Annotate output with reference counts of the objects written. </td></tr>
</table>
</dl>
    </td>
  </tr>
</table>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="a0" doxytag="SoOutput::SoOutput" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> SoOutput::SoOutput           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The default constructor makes an SoOutput instance which will write to the standard output.<p>
<dl compact><dt><b>See also:</b></dt><dd>setFilePointer(), openFile(), setBuffer() </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a1" doxytag="SoOutput::SoOutput" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> SoOutput::SoOutput           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classSoOutput.html">SoOutput</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>dictOut</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Constructs an SoOutput which has a copy of the reference <a class="el" href="classSbDict.html">SbDict</a> instance from <em>dictOut</em>.     </td>
  </tr>
</table>
<a class="anchor" name="a2" doxytag="SoOutput::~SoOutput" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> SoOutput::~<a class="el" href="classSoOutput.html">SoOutput</a>           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Destructor.     </td>
  </tr>
</table>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="a3" doxytag="SoOutput::setFilePointer" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoOutput::setFilePointer           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">FILE *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>newFP</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set up a new file pointer which we will write to.<p>
Important note: do <em>not</em> use this method when the Coin library has been compiled as an MSWindows DLL, as passing FILE* instances back or forth to DLLs is dangerous and will most likely cause a crash. This is an intrinsic limitation for MSWindows DLLs.<p>
<dl compact><dt><b>See also:</b></dt><dd>openFile(), setBuffer(), <a class="el" href="classSoOutput.html#a4">getFilePointer()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a4" doxytag="SoOutput::getFilePointer" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> FILE * SoOutput::getFilePointer           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the current filepointer. If we're writing to a memory buffer, <code>NULL</code> is returned.<p>
Important note: do <em>not</em> use this method when the Coin library has been compiled as an MSWindows DLL, as passing FILE* instances back or forth to DLLs is dangerous and will most likely cause a crash. This is an intrinsic limitation for MSWindows DLLs.<p>
<dl compact><dt><b>See also:</b></dt><dd>setFilePointer() </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a5" doxytag="SoOutput::openFile" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> SbBool SoOutput::openFile           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *const&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>fileName</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Opens a file for writing. If the file can not be opened or is not writeable, <em>FALSE</em> will be returned.<p>
Files opened by this method will automatically be closed if the user supplies another filepointer, another filename for writing, or if the SoOutput instance is deleted.<p>
<dl compact><dt><b>See also:</b></dt><dd>setFilePointer(), setBuffer(), <a class="el" href="classSoOutput.html#a6">closeFile()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a6" doxytag="SoOutput::closeFile" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoOutput::closeFile           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Closes the currently opened file, but only if the file was passed to SoOutput through the openFile() method.<p>
<dl compact><dt><b>See also:</b></dt><dd>openFile() </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a7" doxytag="SoOutput::setCompression" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> SbBool SoOutput::setCompression           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classSbName.html">SbName</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>compmethod</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>const float&nbsp;</td>
          <td class="mdname" nowrap> <em>level</em> = <code>0.5f</code></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets the compression method and level used when writing the file. <em>compmethod</em> is the compression library/method to use when compressing. <em>level</em> is the compression level, where 0.0 means no compression and 1.0 means maximum compression.<p>
Currently <em>BZIP2</em>, <em>GZIP</em> are the only compression methods supported, and you have to compile Coin with zlib and bzip2-support to enable them.<p>
Supply <em>compmethod</em> = <em>NONE</em> or <em>level</em> = 0.0 if you want to disable compression. The compression is disabled by default.<p>
Please note that it's not possible to compress when writing to a memory buffer.<p>
This method will return <em>TRUE</em> if the compression method selected is available. If it's not available, <em>FALSE</em> will be returned and compression is disabled.<p>
<dl compact><dt><b>See also:</b></dt><dd>getAvailableCompressionMethods() </dd></dl>
<dl compact><dt><b>Since:</b></dt><dd>Coin 2.1 </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="e0" doxytag="SoOutput::getAvailableCompressionMethods" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> const <a class="el" href="classSbName.html">SbName</a> * SoOutput::getAvailableCompressionMethods           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned int &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>num</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the array of available compression methods. The number of elements in the array will be stored in <em>num</em>.<p>
<dl compact><dt><b>See also:</b></dt><dd>setCompression() </dd></dl>
<dl compact><dt><b>Since:</b></dt><dd>Coin 2.1 </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a8" doxytag="SoOutput::setBuffer" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoOutput::setBuffer           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void *&nbsp;</td>
          <td class="mdname" nowrap> <em>bufPointer</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>size_t&nbsp;</td>
          <td class="mdname" nowrap> <em>initSize</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>SoOutputReallocCB *&nbsp;</td>
          <td class="mdname" nowrap> <em>reallocFunc</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>int32_t&nbsp;</td>
          <td class="mdname" nowrap> <em>offset</em> = <code>0</code></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets up a memory buffer of size <em>initSize</em> for writing. Writing will start at <em>bufPointer</em> + <em>offset</em>.<p>
If the buffer is filled up, <em>reallocFunc</em> is called to get more memory. If <em>reallocFunc</em> returns <em>NULL</em>, further writing is disabled.<p>
Important note: remember that the resultant memory buffer after write operations have completed may reside somewhere else in memory than on <em>bufPointer</em> if <em>reallocFunc</em> is set. It is a good idea to make it a habit to always use getBuffer() to retrieve the memory buffer pointer after write operations.<p>
Here's a complete, stand-alone usage example which shows how to write a scene graph to a memory buffer:<p>
<pre><div class="fragment"><span class="preprocessor">  #include &lt;Inventor/SoDB.h&gt;</span>
<span class="preprocessor">  #include &lt;Inventor/actions/SoWriteAction.h&gt;</span>
<span class="preprocessor">  #include &lt;Inventor/nodes/SoCone.h&gt;</span>
<span class="preprocessor">  #include &lt;Inventor/nodes/SoSeparator.h&gt;</span>
  
  <span class="keyword">static</span> <span class="keywordtype">char</span> * buffer;
  <span class="keyword">static</span> size_t buffer_size = 0;
  
  <span class="keyword">static</span> <span class="keywordtype">void</span> *
  buffer_realloc(<span class="keywordtype">void</span> * bufptr, size_t size)
  {
    buffer = (<span class="keywordtype">char</span> *)realloc(bufptr, size);
    buffer_size = size;
    <span class="keywordflow">return</span> buffer;
  }
  
  <span class="keyword">static</span> <a class="code" href="classSbString.html">SbString</a>
  buffer_writeaction(<a class="code" href="classSoNode.html">SoNode</a> * root)
  {
    <a class="code" href="classSoOutput.html">SoOutput</a> out;
    buffer = (<span class="keywordtype">char</span> *)malloc(1024);
    buffer_size = 1024;
    out.<a class="code" href="classSoOutput.html#a8">setBuffer</a>(buffer, buffer_size, buffer_realloc);
  
    <a class="code" href="classSoWriteAction.html">SoWriteAction</a> wa(&amp;out);
    wa.<a class="code" href="classSoAction.html#a3">apply</a>(root);
  
    <a class="code" href="classSbString.html">SbString</a> s(buffer);
    free(buffer);
    <span class="keywordflow">return</span> s;
  }
  
  <span class="keywordtype">int</span>
  main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> ** argv)
  {
    <a class="code" href="classSoDB.html#e0">SoDB::init</a>();
  
    SoSeparator * root = <span class="keyword">new</span> SoSeparator;
    root-&gt;<a class="code" href="classSoBase.html#a0">ref</a>();
  
    root-&gt;<a class="code" href="classSoGroup.html#a3">addChild</a>(<span class="keyword">new</span> <a class="code" href="classSoCone.html">SoCone</a>);
  
    <a class="code" href="classSbString.html">SbString</a> s = buffer_writeaction(root);
    (<span class="keywordtype">void</span>)fprintf(stdout, <span class="stringliteral">"%s\n"</span>, s.<a class="code" href="classSbString.html#a9">getString</a>());
  
    root-&gt;<a class="code" href="classSoBase.html#a1">unref</a>();
    <span class="keywordflow">return</span> 0;
  }
</div></pre><p>
<dl compact><dt><b>See also:</b></dt><dd>getBuffer(), <a class="el" href="classSoOutput.html#a10">getBufferSize()</a>, <a class="el" href="classSoOutput.html#a11">resetBuffer()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a9" doxytag="SoOutput::getBuffer" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> SbBool SoOutput::getBuffer           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void *&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>bufPointer</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>size_t &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>nBytes</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const<code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the current buffer in <em>bufPointer</em> and the current write position of the buffer in <em>nBytes</em>. If we're writing into a file and not a memory buffer, <em>FALSE</em> is returned and the other return values will be undefined.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSoOutput.html#a10">getBufferSize()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a10" doxytag="SoOutput::getBufferSize" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> size_t SoOutput::getBufferSize           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns total size of memory buffer.<p>
<dl compact><dt><b>See also:</b></dt><dd>getBuffer() </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a11" doxytag="SoOutput::resetBuffer" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoOutput::resetBuffer           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Reset the memory buffer write pointer back to the beginning of the buffer.     </td>
  </tr>
</table>
<a class="anchor" name="a12" doxytag="SoOutput::setBinary" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoOutput::setBinary           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const SbBool&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>flag</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set whether or not to write the output as a binary stream.<p>
<dl compact><dt><b>See also:</b></dt><dd>isBinary() </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a13" doxytag="SoOutput::isBinary" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> SbBool SoOutput::isBinary           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns a flag which indicates whether or not we're writing the output as a binary stream.<p>
<dl compact><dt><b>See also:</b></dt><dd>setBinary() </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a14" doxytag="SoOutput::setHeaderString" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoOutput::setHeaderString           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classSbString.html">SbString</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>str</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the output file header string.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSoOutput.html#a15">resetHeaderString()</a>, <a class="el" href="classSoOutput.html#e1">getDefaultASCIIHeader()</a>, <a class="el" href="classSoOutput.html#e2">getDefaultBinaryHeader()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a15" doxytag="SoOutput::resetHeaderString" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoOutput::resetHeaderString           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Reset the header string to the default one.<p>
<dl compact><dt><b>See also:</b></dt><dd>setHeaderString(), <a class="el" href="classSoOutput.html#e1">getDefaultASCIIHeader()</a>, <a class="el" href="classSoOutput.html#e2">getDefaultBinaryHeader()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a16" doxytag="SoOutput::setFloatPrecision" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoOutput::setFloatPrecision           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>precision</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the precision used when writing floating point numbers to ASCII files. <em>precision</em> should be between 0 and 8. The double precision will be set to <em>precision</em> * 2.     </td>
  </tr>
</table>
<a class="anchor" name="a17" doxytag="SoOutput::setStage" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoOutput::setStage           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classSoOutput.html#w4">Stage</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>stage</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets an indicator on the current stage. This is necessary to do as writing has to be done in multiple stages to account for the export of references/connections within the scene graphs.<p>
This method is basically just used from within <a class="el" href="classSoWriteAction.html">SoWriteAction</a>, and should usually not be of interest to the application programmer. Do not use it unless you <em>really</em> know what you are doing.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSoOutput.html#a18">getStage()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a18" doxytag="SoOutput::getStage" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classSoOutput.html#w4">SoOutput::Stage</a> SoOutput::getStage           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns an indicator on the current write stage. Writing is done in two passes, one to count and check connections, one to do the actual ascii or binary export of data.<p>
You should not need to use this method, as it is meant for internal purposes in Coin.<p>
<dl compact><dt><b>See also:</b></dt><dd>setStage() </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a19" doxytag="SoOutput::incrementIndent" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoOutput::incrementIndent           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>levels</em> = <code>1</code>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Increase indentation level in the file.<p>
<dl compact><dt><b>See also:</b></dt><dd>decrementIndent(), <a class="el" href="classSoOutput.html#a35">indent()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a20" doxytag="SoOutput::decrementIndent" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoOutput::decrementIndent           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>levels</em> = <code>1</code>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Decrease indentation level in the file.<p>
<dl compact><dt><b>See also:</b></dt><dd>incrementIndent(), <a class="el" href="classSoOutput.html#a35">indent()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a21" doxytag="SoOutput::write" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoOutput::write           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>c</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Write the character in <em>c</em>.<p>
For binary write, the character plus 3 padding zero characters will be written.     </td>
  </tr>
</table>
<a class="anchor" name="a22" doxytag="SoOutput::write" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoOutput::write           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>s</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Write the character string pointed to by <em>s</em>.<p>
For binary write, a 4-byte MSB-ordered integer with the string length, plus the string plus padding zero characters to get on a 4-byte boundary (if necessary) will be written.     </td>
  </tr>
</table>
<a class="anchor" name="a23" doxytag="SoOutput::write" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoOutput::write           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classSbString.html">SbString</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>s</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Write the character string in <em>s</em>. The string will be written with apostrophes. Cast <a class="el" href="classSbString.html">SbString</a> to char * to write without apostrophes.<p>
If we are supposed to write in binary format, no apostrophes will be added, and writing will be done in the exact same manner as with <a class="el" href="classSoOutput.html#a22">SoOutput::write(const char * s)</a>.     </td>
  </tr>
</table>
<a class="anchor" name="a24" doxytag="SoOutput::write" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoOutput::write           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classSbName.html">SbName</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>n</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Write the character string in <em>n</em>. The name will be enclosed by apostrophes. If you want to write an <a class="el" href="classSbName.html">SbName</a> instance without the apostrophes, cast the argument to a char *.<p>
If we are supposed to write in binary format, no apostrophes will be added, and writing will be done in the exact same manner as with <a class="el" href="classSoOutput.html#a22">SoOutput::write(const char * s)</a>.     </td>
  </tr>
</table>
<a class="anchor" name="a25" doxytag="SoOutput::write" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoOutput::write           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>i</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Write <em>i</em> as a character string, or as an architecture independent binary pattern if the setBinary() flag is activated.     </td>
  </tr>
</table>
<a class="anchor" name="a26" doxytag="SoOutput::write" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoOutput::write           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const unsigned int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>i</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Write <em>i</em> as a character string, or as an architecture independent binary pattern if the setBinary() flag is activated.     </td>
  </tr>
</table>
<a class="anchor" name="a27" doxytag="SoOutput::write" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoOutput::write           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const short&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>s</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Write <em>s</em> as a character string, or as an architecture independent binary pattern if the setBinary() flag is activated.     </td>
  </tr>
</table>
<a class="anchor" name="a28" doxytag="SoOutput::write" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoOutput::write           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const unsigned short&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>s</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Write <em>s</em> as a character string, or as an architecture independent binary pattern if the setBinary() flag is activated. If we're writing in ASCII format, the value will be written in base 16 (hexadecimal).     </td>
  </tr>
</table>
<a class="anchor" name="a29" doxytag="SoOutput::write" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoOutput::write           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const float&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>f</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Write <em>f</em> as a character string.     </td>
  </tr>
</table>
<a class="anchor" name="a30" doxytag="SoOutput::write" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoOutput::write           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const double&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>d</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Write <em>d</em> as a character string.     </td>
  </tr>
</table>
<a class="anchor" name="a31" doxytag="SoOutput::writeBinaryArray" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoOutput::writeBinaryArray           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const unsigned char *&nbsp;</td>
          <td class="mdname" nowrap> <em>constc</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>length</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Write the given number of bytes to either a file or a memory buffer in binary format.     </td>
  </tr>
</table>
<a class="anchor" name="a32" doxytag="SoOutput::writeBinaryArray" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoOutput::writeBinaryArray           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const int32_t *const&nbsp;</td>
          <td class="mdname" nowrap> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>length</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Write an <em>length</em> array of int32_t values in binary format.     </td>
  </tr>
</table>
<a class="anchor" name="a33" doxytag="SoOutput::writeBinaryArray" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoOutput::writeBinaryArray           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const float *const&nbsp;</td>
          <td class="mdname" nowrap> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>length</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Write an array of float values in binary format.     </td>
  </tr>
</table>
<a class="anchor" name="a34" doxytag="SoOutput::writeBinaryArray" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoOutput::writeBinaryArray           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const double *const&nbsp;</td>
          <td class="mdname" nowrap> <em>d</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>length</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Write an array of double values in binary format.     </td>
  </tr>
</table>
<a class="anchor" name="a35" doxytag="SoOutput::indent" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoOutput::indent           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Call this method after writing a newline to a file to indent the next line to the correct position.<p>
<dl compact><dt><b>See also:</b></dt><dd>incrementIndent(), decrementIndent() </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a36" doxytag="SoOutput::reset" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoOutput::reset           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Reset all value and make ready for using another filepointer or buffer.     </td>
  </tr>
</table>
<a class="anchor" name="a37" doxytag="SoOutput::setCompact" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoOutput::setCompact           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">SbBool&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>flag</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set up the output to be more compact than with the default write routines.     </td>
  </tr>
</table>
<a class="anchor" name="a38" doxytag="SoOutput::isCompact" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> SbBool SoOutput::isCompact           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns whether or not the write routines tries to compact the data when writing it (i.e. using less whitespace, etc).<p>
Note that "compact" in this sense does <em>not</em> mean "bitwise compression", as it could easily be mistaken for.     </td>
  </tr>
</table>
<a class="anchor" name="a39" doxytag="SoOutput::setAnnotation" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoOutput::setAnnotation           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">uint32_t&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>bits</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set up annotation of different aspects of the output data. This is not useful for much else than debugging purposes, I s'pose.     </td>
  </tr>
</table>
<a class="anchor" name="a40" doxytag="SoOutput::getAnnotation" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> uint32_t SoOutput::getAnnotation           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the current annotation debug bitflag settings.     </td>
  </tr>
</table>
<a class="anchor" name="e1" doxytag="SoOutput::getDefaultASCIIHeader" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classSbString.html">SbString</a> SoOutput::getDefaultASCIIHeader           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the default header string written to ASCII files.<p>
<dl compact><dt><b>See also:</b></dt><dd>setHeaderString(), <a class="el" href="classSoOutput.html#a15">resetHeaderString()</a>, <a class="el" href="classSoOutput.html#e2">getDefaultBinaryHeader()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="e2" doxytag="SoOutput::getDefaultBinaryHeader" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classSbString.html">SbString</a> SoOutput::getDefaultBinaryHeader           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the default header string written to binary files.<p>
<dl compact><dt><b>See also:</b></dt><dd>setHeaderString(), <a class="el" href="classSoOutput.html#a15">resetHeaderString()</a>, <a class="el" href="classSoOutput.html#e1">getDefaultASCIIHeader()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a41" doxytag="SoOutput::addReference" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int SoOutput::addReference           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classSoBase.html">SoBase</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>base</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Makes a unique id for <em>base</em> and adds a mapping into our dictionary.     </td>
  </tr>
</table>
<a class="anchor" name="a42" doxytag="SoOutput::findReference" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int SoOutput::findReference           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classSoBase.html">SoBase</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>base</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the unique identifier for <em>base</em> or -1 if not found.     </td>
  </tr>
</table>
<a class="anchor" name="a43" doxytag="SoOutput::setReference" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoOutput::setReference           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classSoBase.html">SoBase</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>base</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>refid</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets the reference for <em>base</em> manually.     </td>
  </tr>
</table>
<a class="anchor" name="a44" doxytag="SoOutput::addDEFNode" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoOutput::addDEFNode           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classSbName.html">SbName</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>name</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Adds <em>name</em> to the set of currently DEF'ed node names so far in the output process.     </td>
  </tr>
</table>
<a class="anchor" name="a45" doxytag="SoOutput::lookupDEFNode" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> SbBool SoOutput::lookupDEFNode           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classSbName.html">SbName</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>name</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Checks whether <em>name</em> is already DEF'ed at this point in the output process. Returns TRUE if <em>name</em> is DEF'ed.     </td>
  </tr>
</table>
<a class="anchor" name="a46" doxytag="SoOutput::removeDEFNode" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoOutput::removeDEFNode           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classSbName.html">SbName</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>name</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Removes <em>name</em> from the set of DEF'ed node names. Used after the last reference to a DEF'ed node if we want to reuse the DEF at a later point in the file.     </td>
  </tr>
</table>
<a class="anchor" name="a47" doxytag="SoOutput::pushProto" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoOutput::pushProto           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">SoProto *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>proto</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em><p>
This function is an extension for Coin, and it is not available in the original SGI Open Inventor v2.1 API.<p>
<dl compact><dt><b>Since:</b></dt><dd>Coin 2.0 </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a48" doxytag="SoOutput::getCurrentProto" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> SoProto * SoOutput::getCurrentProto           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em><p>
This function is an extension for Coin, and it is not available in the original SGI Open Inventor v2.1 API.<p>
<dl compact><dt><b>Since:</b></dt><dd>Coin 2.0 </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a49" doxytag="SoOutput::popProto" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoOutput::popProto           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em><p>
This function is an extension for Coin, and it is not available in the original SGI Open Inventor v2.1 API.<p>
<dl compact><dt><b>Since:</b></dt><dd>Coin 2.0 </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a50" doxytag="SoOutput::addRoute" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoOutput::addRoute           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classSoFieldContainer.html">SoFieldContainer</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>from</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>const <a class="el" href="classSbName.html">SbName</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>fromfield</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classSoFieldContainer.html">SoFieldContainer</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>to</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>const <a class="el" href="classSbName.html">SbName</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>tofield</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em><p>
This function is an extension for Coin, and it is not available in the original SGI Open Inventor v2.1 API.<p>
<dl compact><dt><b>Since:</b></dt><dd>Coin 2.0 </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a51" doxytag="SoOutput::resolveRoutes" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoOutput::resolveRoutes           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em><p>
This function is an extension for Coin, and it is not available in the original SGI Open Inventor v2.1 API.<p>
<dl compact><dt><b>Since:</b></dt><dd>Coin 2.0 </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="b0" doxytag="SoOutput::isToBuffer" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> SbBool SoOutput::isToBuffer           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [protected]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns <em>TRUE</em> of we're set up to write to a memory buffer.     </td>
  </tr>
</table>
<a class="anchor" name="b1" doxytag="SoOutput::bytesInBuf" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> size_t SoOutput::bytesInBuf           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [protected]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns current write position.<p>
Note that for memory buffer writing, this includes the offset from SoOutput::setBuffer(), if any.     </td>
  </tr>
</table>
<a class="anchor" name="b2" doxytag="SoOutput::makeRoomInBuf" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> SbBool SoOutput::makeRoomInBuf           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">size_t&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>bytes</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [protected]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Check that the current memory buffer has enough space to contain the given number of bytes needed for the next write operation.<p>
Returns <em>FALSE</em> if there's not enough space left, otherwise <em>TRUE</em>.<p>
Note that there will automatically be made an attempt at allocating more memory if the realloction callback function argument of setBuffer() was not <em>NULL</em>.     </td>
  </tr>
</table>
<a class="anchor" name="b3" doxytag="SoOutput::convertShort" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoOutput::convertShort           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">short&nbsp;</td>
          <td class="mdname" nowrap> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap> <em>to</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [protected]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Convert the short integer in <em>s</em> to most-significant-byte first format and put the resulting bytes sequentially at <em>to</em>.<p>
<dl compact><dt><b>See also:</b></dt><dd>SoInput::convertShort() </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="b4" doxytag="SoOutput::convertInt32" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoOutput::convertInt32           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int32_t&nbsp;</td>
          <td class="mdname" nowrap> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap> <em>to</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [protected]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Convert the 32-bit integer in <em>l</em> to most-significant-byte first format and put the resulting bytes sequentially at <em>to</em>.<p>
<dl compact><dt><b>See also:</b></dt><dd>SoInput::convertInt32() </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="b5" doxytag="SoOutput::convertFloat" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoOutput::convertFloat           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">float&nbsp;</td>
          <td class="mdname" nowrap> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap> <em>to</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [protected]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Convert the single-precision floating point number in <em>f</em> to most-significant-byte first format and put the resulting bytes sequentially at <em>to</em>.<p>
<dl compact><dt><b>See also:</b></dt><dd>SoInput::convertFloat() </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="b6" doxytag="SoOutput::convertDouble" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoOutput::convertDouble           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">double&nbsp;</td>
          <td class="mdname" nowrap> <em>d</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap> <em>to</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [protected]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Convert the double-precision floating point number in <em>d</em> to most-significant-byte first format and put the resulting bytes sequentially at <em>to</em>.<p>
<dl compact><dt><b>See also:</b></dt><dd>SoInput::convertDouble() </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="b7" doxytag="SoOutput::convertShortArray" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoOutput::convertShortArray           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">short *&nbsp;</td>
          <td class="mdname" nowrap> <em>from</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap> <em>to</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>len</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [protected]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Convert <em>len</em> short integer values from the array at <em>from</em> into the array at <em>to</em> from native host format to network independent format (i.e. most significant byte first).     </td>
  </tr>
</table>
<a class="anchor" name="b8" doxytag="SoOutput::convertInt32Array" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoOutput::convertInt32Array           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int32_t *&nbsp;</td>
          <td class="mdname" nowrap> <em>from</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap> <em>to</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>len</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [protected]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Convert <em>len</em> 32-bit integer values from the array at <em>from</em> into the array at <em>to</em> from native host format to network independent format (i.e. most significant byte first).     </td>
  </tr>
</table>
<a class="anchor" name="b9" doxytag="SoOutput::convertFloatArray" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoOutput::convertFloatArray           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">float *&nbsp;</td>
          <td class="mdname" nowrap> <em>from</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap> <em>to</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>len</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [protected]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Convert <em>len</em> single-precision floating point values from the array at <em>from</em> into the array at <em>to</em> from native host format to network independent format (i.e. most significant byte first).     </td>
  </tr>
</table>
<a class="anchor" name="b10" doxytag="SoOutput::convertDoubleArray" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoOutput::convertDoubleArray           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">double *&nbsp;</td>
          <td class="mdname" nowrap> <em>from</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap> <em>to</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>len</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [protected]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Convert <em>len</em> double-precision floating point values from the array at <em>from</em> into the array at <em>to</em> from native host format to network independent format (i.e. most significant byte first).     </td>
  </tr>
</table>
<a class="anchor" name="f0" doxytag="SoOutput::padHeader" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classSbString.html">SbString</a> SoOutput::padHeader           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classSbString.html">SbString</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>inString</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static, protected]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Pads the header we're writing so it contains the correct amount of bytes for the alignment of the following binary writes.     </td>
  </tr>
</table>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="p0" doxytag="SoOutput::wroteHeader" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> SbBool <a class="el" href="classSoOutput.html#p0">SoOutput::wroteHeader</a><code> [protected]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Indicates whether or not the file format header has been written out. As long as this is <em>FALSE</em>, the header will be written once upon the first invocation of any write method in the class.     </td>
  </tr>
</table>
<hr>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="SoOutput_8h-source.html">SoOutput.h</a><li>SoOutput.cpp</ul>
<hr noshade>
<p align="right">Copyright &copy 1998-2004 by <a href="http://www.sim.no">Systems in Motion AS</a>. All rights reserved.</p>
<address style="align: right;"><small>
Generated on Mon Oct 18 01:25:17 2004 for Coin by <a href="http://www.doxygen.org/index.html">Doxygen.</a> 1.3.7</small></address>
</body>
</html>
