<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SoGLRenderAction class Reference</title>
<link href="stylesheet.css" rel="stylesheet" type="text/css">
</head><body><table width="100%">
<tr>
  <td>
    <img src="Coin_logo.png" alt="Coin Logo">
  </td>
  <td align="right">
    <a href="http://www.sim.no">http://www.sim.no</a><br>
    <a href="http://www.coin3d.org/">http://www.coin3d.org</a>
  </td>
</tr>
</table>
<hr noshade>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>SoGLRenderAction Class Reference<br>
<small>
[<a class="el" href="group__actions.html">Actions</a>]</small>
</h1><code>#include &lt;<a class="el" href="SoGLRenderAction_8h-source.html">Inventor/actions/SoGLRenderAction.h</a>&gt;</code>
<p>
<p>Inheritance diagram for SoGLRenderAction:
<p><center><img src="classSoGLRenderAction.png" usemap="#SoGLRenderAction_map" border="0" alt=""></center>
<map name="SoGLRenderAction_map">
<area href="classSoAction.html" alt="SoAction" shape="rect" coords="93,0,270,24">
<area href="classSoBoxHighlightRenderAction.html" alt="SoBoxHighlightRenderAction" shape="rect" coords="0,112,177,136">
<area href="classSoLineHighlightRenderAction.html" alt="SoLineHighlightRenderAction" shape="rect" coords="187,112,364,136">
</map>
<a href="classSoGLRenderAction-members.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>
The SoGLRenderAction class renders the scene graph with OpenGL calls. 
<p>
Applying this method at a root node for a scene graph, path or pathlist will render all geometry contained within that instance to the current OpenGL context. 
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>typedef <a class="el" href="classSoGLRenderAction.html#w17">AbortCode</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoGLRenderAction.html#w0">SoGLRenderAbortCB</a> (void *userdata)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>enum &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoGLRenderAction.html#w16">TransparencyType</a> { <br>
&nbsp;&nbsp;<a class="el" href="classSoGLRenderAction.html#w16w1">SCREEN_DOOR</a>, 
<a class="el" href="classSoGLRenderAction.html#w16w2">ADD</a>, 
<a class="el" href="classSoGLRenderAction.html#w16w3">DELAYED_ADD</a>, 
<a class="el" href="classSoGLRenderAction.html#w16w4">SORTED_OBJECT_ADD</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="classSoGLRenderAction.html#w16w5">BLEND</a>, 
<a class="el" href="classSoGLRenderAction.html#w16w6">DELAYED_BLEND</a>, 
<a class="el" href="classSoGLRenderAction.html#w16w7">SORTED_OBJECT_BLEND</a>, 
<a class="el" href="classSoGLRenderAction.html#w16w8">SORTED_OBJECT_SORTED_TRIANGLE_ADD</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="classSoGLRenderAction.html#w16w9">SORTED_OBJECT_SORTED_TRIANGLE_BLEND</a>, 
<a class="el" href="classSoGLRenderAction.html#w16w10">NONE</a>, 
<a class="el" href="classSoGLRenderAction.html#w16w11">SORTED_LAYERS_BLEND</a>
<br>
 }</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>enum &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoGLRenderAction.html#w17">AbortCode</a> { <a class="el" href="classSoGLRenderAction.html#w17w12">CONTINUE</a>, 
<a class="el" href="classSoGLRenderAction.html#w17w13">ABORT</a>, 
<a class="el" href="classSoGLRenderAction.html#w17w14">PRUNE</a>, 
<a class="el" href="classSoGLRenderAction.html#w17w15">DELAY</a>
 }</td></tr>

<tr><td colspan=2><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>virtual <a class="el" href="classSoType.html">SoType</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoGLRenderAction.html#a0">getTypeId</a> (void) const</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoGLRenderAction.html#a1">SoGLRenderAction</a> (const <a class="el" href="classSbViewportRegion.html">SbViewportRegion</a> &amp;viewportregion)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoGLRenderAction.html#a2">~SoGLRenderAction</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoGLRenderAction.html#a3">setViewportRegion</a> (const <a class="el" href="classSbViewportRegion.html">SbViewportRegion</a> &amp;newregion)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>const <a class="el" href="classSbViewportRegion.html">SbViewportRegion</a> &amp;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoGLRenderAction.html#a4">getViewportRegion</a> (void) const</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoGLRenderAction.html#a5">setUpdateArea</a> (const <a class="el" href="classSbVec2f.html">SbVec2f</a> &amp;origin, const <a class="el" href="classSbVec2f.html">SbVec2f</a> &amp;size)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoGLRenderAction.html#a6">getUpdateArea</a> (<a class="el" href="classSbVec2f.html">SbVec2f</a> &amp;origin, <a class="el" href="classSbVec2f.html">SbVec2f</a> &amp;size) const</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoGLRenderAction.html#a7">setAbortCallback</a> (<a class="el" href="classSoGLRenderAction.html#w0">SoGLRenderAbortCB</a> *const func, void *const userdata)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoGLRenderAction.html#a8">setTransparencyType</a> (const <a class="el" href="classSoGLRenderAction.html#w16">TransparencyType</a> type)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="classSoGLRenderAction.html#w16">TransparencyType</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoGLRenderAction.html#a9">getTransparencyType</a> (void) const</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoGLRenderAction.html#a10">setSmoothing</a> (const SbBool smooth)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>SbBool&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoGLRenderAction.html#a11">isSmoothing</a> (void) const</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoGLRenderAction.html#a12">setNumPasses</a> (const int num)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoGLRenderAction.html#a13">getNumPasses</a> (void) const</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoGLRenderAction.html#a14">setPassUpdate</a> (const SbBool flag)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>SbBool&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoGLRenderAction.html#a15">isPassUpdate</a> (void) const</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoGLRenderAction.html#a16">setPassCallback</a> (SoGLRenderPassCB *const func, void *const userdata)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoGLRenderAction.html#a17">setCacheContext</a> (const uint32_t context)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>uint32_t&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoGLRenderAction.html#a18">getCacheContext</a> (void) const</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoGLRenderAction.html#a19">addDelayedPath</a> (<a class="el" href="classSoPath.html">SoPath</a> *path)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>SbBool&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoGLRenderAction.html#a20">isRenderingDelayedPaths</a> (void) const</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>SbBool&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoGLRenderAction.html#a21">handleTransparency</a> (SbBool istransparent=0)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoGLRenderAction.html#a22">getCurPass</a> (void) const</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>SbBool&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoGLRenderAction.html#a23">abortNow</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoGLRenderAction.html#a24">setRenderingIsRemote</a> (SbBool isremote)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>SbBool&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoGLRenderAction.html#a25">getRenderingIsRemote</a> (void) const</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoGLRenderAction.html#a26">invalidateState</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoGLRenderAction.html#a27">addPreRenderCallback</a> (SoGLPreRenderCB *func, void *userdata)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoGLRenderAction.html#a28">removePreRenderCallback</a> (SoGLPreRenderCB *func, void *userdata)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoGLRenderAction.html#a29">setSortedLayersNumPasses</a> (int num)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoGLRenderAction.html#a30">getSortedLayersNumPasses</a> () const</td></tr>

<tr><td colspan=2><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="classSoType.html">SoType</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoGLRenderAction.html#e0">getClassTypeId</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoGLRenderAction.html#e1">addMethod</a> (const <a class="el" href="classSoType.html">SoType</a> type, SoActionMethod method)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoGLRenderAction.html#e2">enableElement</a> (const <a class="el" href="classSoType.html">SoType</a> type, const int stackindex)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoGLRenderAction.html#e3">initClass</a> (void)</td></tr>

<tr><td colspan=2><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>virtual const <a class="el" href="classSoEnabledElementsList.html">SoEnabledElementsList</a> &amp;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoGLRenderAction.html#b0">getEnabledElements</a> (void) const</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoGLRenderAction.html#b1">beginTraversal</a> (<a class="el" href="classSoNode.html">SoNode</a> *node)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoGLRenderAction.html#b2">endTraversal</a> (<a class="el" href="classSoNode.html">SoNode</a> *node)</td></tr>

<tr><td colspan=2><br><h2>Static Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="classSoEnabledElementsList.html">SoEnabledElementsList</a> *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoGLRenderAction.html#f0">getClassEnabledElements</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="classSoActionMethodList.html">SoActionMethodList</a> *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoGLRenderAction.html#f1">getClassActionMethods</a> (void)</td></tr>

</table>
<hr><h2>Member Typedef Documentation</h2>
<a class="anchor" name="w0" doxytag="SoGLRenderAction::SoGLRenderAbortCB" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> typedef <a class="el" href="classSoGLRenderAction.html#w0">SoGLRenderAction::SoGLRenderAbortCB</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Abort callbacks should be of this type. <dl compact><dt><b>See also:</b></dt><dd>setAbortCallback() </dd></dl>
    </td>
  </tr>
</table>
<hr><h2>Member Enumeration Documentation</h2>
<a class="anchor" name="w16" doxytag="SoGLRenderAction::TransparencyType" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> enum <a class="el" href="classSoGLRenderAction.html#w16">SoGLRenderAction::TransparencyType</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Various settings for how to do rendering of transparent objects in the scene. Some of the settings will provide faster rendering, while others gives you better quality rendering.<p>
Note that doing correct rendering of <em>multiple</em> transparent objects often fails, because to be 100% correct, all polygons needs to be rendered in sorted order, and polygons can't intersect each other. In a dynamic scene graph it is often impossible to guarantee that no polygons intersect, and finding an algorithm that does correct sorting of polygons for all possible cases is very hard and time-consuming.<p>
The highest quality transparency mode in the original SGI / TGS Open Inventor is <a class="el" href="classSoGLRenderAction.html#w16w7">SoGLRenderAction::SORTED_OBJECT_BLEND</a>, where all transparent objects are rendered in sorted order in a rendering pass after all opaque objects. However, this mode does not sort the polygons, and if you have an object where some polygon A is behind some other polygon B, the transparency will only be correct if A happens to be rendered before B. For other camera angles, where B is behind A, the transparency will not be correct.<p>
In Coin we have a new transparency mode that solves some of these problems: <a class="el" href="classSoGLRenderAction.html#w16w9">SoGLRenderAction::SORTED_OBJECT_SORTED_TRIANGLE_BLEND</a>. In addition to sorting the objects, all polygons inside each object is also sorted back-to-front when rendering. But, if you have intersecting objects and/or intersecting polygons, even this transparency mode will fail. Also, because of the polygon sorting, this transparency mode is quite slow. It is possible to speed things up using the <a class="el" href="classSoTransparencyType.html">SoTransparencyType</a> node, though, which enables you to set different transparency modes for different parts of the scene graph. If you have only have a few objects where you need to sort the polygons, you can use <a class="el" href="classSoGLRenderAction.html#w16w9">SoGLRenderAction::SORTED_OBJECT_SORTED_TRIANGLE_BLEND</a> for those, and for instance <a class="el" href="classSoGLRenderAction.html#w16w7">SoGLRenderAction::SORTED_OBJECT_BLEND</a> for all other transparent objects.<p>
The highest quality transparency mode in Coin is <a class="el" href="classSoGLRenderAction.html#w16w11">SoGLRenderAction::SORTED_LAYERS_BLEND</a>. It is also the only mode that overrides all other modes in the scenegraph.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSoTransparencyType.html">SoTransparencyType</a> </dd></dl>
<dl compact><dt><b>Enumeration values: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="anchor" name="w16w1" doxytag="SCREEN_DOOR" ></a>SCREEN_DOOR</em>&nbsp;</td><td>
Transparent triangles are rendered with a dither pattern. This is a fast (on most GFX cards) but not-so-high-quality transparency mode.<p>
One particular feature of this mode is that you are guaranteed that it always renders the transparent parts of the scene correct with regard to internal depth ordering of objects / polygons, something which is not the case for any other transparency mode.<p>
Polygons rendered with only transparent textures are not shown as being transparent when using this mode. The reason being that the SCREEN_DOOR mode is working on polygons, not pixels. To render polygons with dither pattern, a material node has to be inserted into the scenegraph with it's transparency field set. </td></tr>
<tr><td valign=top><em><a class="anchor" name="w16w2" doxytag="ADD" ></a>ADD</em>&nbsp;</td><td>
Transparent objects are rendered using additive alpha blending. Additive blending is probably mostly used to create special transparency effects. The new pixel color is calculated as the current pixel color plus the source pixel color multiplied with the source pixel alpha value. </td></tr>
<tr><td valign=top><em><a class="anchor" name="w16w3" doxytag="DELAYED_ADD" ></a>DELAYED_ADD</em>&nbsp;</td><td>
<a class="el" href="classSoGLRenderAction.html#w16w3">SoGLRenderAction::DELAYED_ADD</a> Transparent objects are rendered using additive alpha blending, in a second rendering pass with depth buffer updates disabled. </td></tr>
<tr><td valign=top><em><a class="anchor" name="w16w4" doxytag="SORTED_OBJECT_ADD" ></a>SORTED_OBJECT_ADD</em>&nbsp;</td><td>
Transparent objects are rendered using additive alpha blending. Opaque objects are rendered first, and transparent objects are rendered back to front with z-buffer updates disabled. </td></tr>
<tr><td valign=top><em><a class="anchor" name="w16w5" doxytag="BLEND" ></a>BLEND</em>&nbsp;</td><td>
Transparent objects are rendered using multiplicative alpha blending.<p>
Multiplicative alpha blending is the blending type that is most often used to render transparent objects. The new pixel value is calculated as the old pixel color multiplied with one minus the source alpha value, plus the source pixel color multiplied with the source alpha value.<p>
We recommend that you use this transparency mode if you have only one transparent object in your scene, and you know that it will be rendered after the opaque objects. </td></tr>
<tr><td valign=top><em><a class="anchor" name="w16w6" doxytag="DELAYED_BLEND" ></a>DELAYED_BLEND</em>&nbsp;</td><td>
Transparent objects are rendered using multiplicative alpha blending, in a second rendering pass with depth buffer updates disabled.<p>
Use this transparency type when you have one transparent object, or several transparent object that you know will never overlap (when projected to screen). Since the transparent objects are rendered after opaque ones, you'll not have to worry about putting the transparent objects at the end of your scene graph. It will not be as fast as the BLEND transparency type, of course, since the scene graph is traversed twice. </td></tr>
<tr><td valign=top><em><a class="anchor" name="w16w7" doxytag="SORTED_OBJECT_BLEND" ></a>SORTED_OBJECT_BLEND</em>&nbsp;</td><td>
Transparent objects are rendered using multiplicative alpha blending, Opaque objects are rendered first, and transparent objects are rendered back to front with z-buffer updates disabled.<p>
Use this transparency mode when you have several transparent object that you know might overlap (when projected to screen). This method will require 1 + num_transparent_objects rendering passes. Path traversal is used when rendering transparent objects, of course, but it might still be slow if you have lots of state changes before your transparent object. When using this mode, we recommend placing the transparent objects as early as possible in the scene graph to minimize traversal overhead. </td></tr>
<tr><td valign=top><em><a class="anchor" name="w16w8" doxytag="SORTED_OBJECT_SORTED_TRIANGLE_ADD" ></a>SORTED_OBJECT_SORTED_TRIANGLE_ADD</em>&nbsp;</td><td>
This transparency type is a Coin extension versus the original SGI Open Inventor API.<p>
Transparent objects are rendered back to front, and triangles in each object are sorted back to front before rendering.<p>
See description for SORTED_OBJECT_SORTED_TRIANGLE_BLEND for more information about this transparency type. </td></tr>
<tr><td valign=top><em><a class="anchor" name="w16w9" doxytag="SORTED_OBJECT_SORTED_TRIANGLE_BLEND" ></a>SORTED_OBJECT_SORTED_TRIANGLE_BLEND</em>&nbsp;</td><td>
This transparency type is a Coin extension versus the original SGI Open Inventor API.<p>
Transparent objects are rendered back to front, and triangles in each object are sorted back to front before rendering.<p>
Use this transparency type when you have one (or more) transparent object(s) where you know triangles might overlap inside the object. This transparency type might be very slow if you have an object with lots of triangles, since all triangles have to be sorted before rendering, and an unoptimized rendering loop is used when rendering. Lines and points are not sorted before rendering. They are rendered as in the normal SORTED_OBJECT_BLEND transparency type.<p>
Please note that this transparency mode does not guarantee "correct" transparency rendering. It is almost impossible to find an algorithm that will sort triangles correctly in all cases, and intersecting triangles are not handled. Also, since each object is handled separately, two intersecting object will lead to incorrect transparency. </td></tr>
<tr><td valign=top><em><a class="anchor" name="w16w10" doxytag="NONE" ></a>NONE</em>&nbsp;</td><td>
This transparency type is a Coin extension versus the Open Inventor API.<p>
Turns off transparency for objects, even if transparency is set using an <a class="el" href="classSoMaterial.html">SoMaterial</a> node. </td></tr>
<tr><td valign=top><em><a class="anchor" name="w16w11" doxytag="SORTED_LAYERS_BLEND" ></a>SORTED_LAYERS_BLEND</em>&nbsp;</td><td>
This transparency type is a Coin extension versus the original SGI Open Inventor API.<p>
By using this transparency type, the SoGLRenderAction will render normal and intersecting transparent objects correctly independent of rendering order. It is the only transparency type rendering mode which is guaranteed to do so.<p>
This mode is different from all other modes in that it overrides the <a class="el" href="classSoTransparencyType.html">SoTransparencyType</a> nodes in the scenegraph; all objects are drawn using SORTED_LAYERS_BLEND.<p>
There are currently two separate code paths for this mode. Both paths are heavily based on OpenGL extensions. The first method is based on extensions which are only available on NVIDIA chipsets (GeForce3 and above, except GeForce4 MX). These extensions are <code>GL_NV_texture_shader</code>, <code>GL_NV_texture_rectangle</code> or <code>GL_EXT_texture_rectangle</code>, <code>GL_NV_register_combiners</code>, <code>GL_ARB_shadow</code> and <code>GL_ARB_depth_texture</code>. Please note that this transparency type occupy all four texture units on the NVIDIA card for all the rendering passes, except the first. Textured surfaces will therefore only be textured if they are not occluded by another transparent surface.<p>
The second method utilise the <code>GL_ARB_fragment_program</code> extension. This extension is currently supported by the GeForceFX family and the Radeon 9500 and above. This technique is faster than the pure NVIDIA method. The fragment program method will automatically be chosen if possible. Please note that one should beware not to place the near-plane too close to the camera due to the lack of floating point precision control in fragment programs. Doing so may lead to loss of precision around the edges and 'jaggedness' of the transparent geometry.<p>
Setting the environment variable COIN_SORTED_LAYERS_USE_NVIDIA_RC to '1' will force the use of former code path instead of the latter, even if it is available.<p>
A rendering context with &gt;= 24 bits depth buffer and 8 bits alpha channel must be the current rendering context for this blending mode to be active.<p>
The detection of whether or not the SORTED_LAYERS_BLEND mode can be used will be done automatically by the Coin internals. If one or more of the necessary conditions listed above are unavailable, <a class="el" href="classSoGLRenderAction.html#w16w7">SoGLRenderAction::SORTED_OBJECT_BLEND</a> will be used as the transparency type instead.<p>
To be able to render correct transparency independent of object order, one have to render in multiple passes. This technique is based on depth-peeling which strips away depth layers with each successive pass. The number of passes is therefore an indication of how deep into the scene transparent surfaces will be rendered with transparency. A higher number will lead to a lower framerate but higher quality for scenes with a lot of transparent surfaces. The default number of passes is '4'. This number can be specified using the SoGLRenderAction::setSortedLayersNumPasses() or by letting the environment variable <code>COIN_NUM_SORTED_LAYERS_PASSES</code> or <code>OIV_NUM_SORTED_LAYERS_PASSES</code> specify the number of passes.<p>
A more detailed presentation of the algorithm is written by Cass Everitt at NVIDIA;<p>
"Interactive Order-Independent Transparency" <a href="http:://developer.nvidia.com/object/order_independent_transparency.html">http:://developer.nvidia.com/object/order_independent_transparency.html</a><p>
<dl compact><dt><b>Since:</b></dt><dd>Coin 2.2 <p>
TGS Inventor 4.0 </dd></dl>
</td></tr>
</table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="w17" doxytag="SoGLRenderAction::AbortCode" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> enum <a class="el" href="classSoGLRenderAction.html#w17">SoGLRenderAction::AbortCode</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The return codes which an SoGLRenderAbortCB callback function should use.<p>
<dl compact><dt><b>See also:</b></dt><dd>setAbortCallback() </dd></dl>
<dl compact><dt><b>Enumeration values: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="anchor" name="w17w12" doxytag="CONTINUE" ></a>CONTINUE</em>&nbsp;</td><td>
Continue rendering as usual. </td></tr>
<tr><td valign=top><em><a class="anchor" name="w17w13" doxytag="ABORT" ></a>ABORT</em>&nbsp;</td><td>
Abort the rendering action immediately. </td></tr>
<tr><td valign=top><em><a class="anchor" name="w17w14" doxytag="PRUNE" ></a>PRUNE</em>&nbsp;</td><td>
Do not render the current node or any of its children, but continue the rendering traversal. </td></tr>
<tr><td valign=top><em><a class="anchor" name="w17w15" doxytag="DELAY" ></a>DELAY</em>&nbsp;</td><td>
Delay rendering of the current node (and its children) until the next rendering pass. </td></tr>
</table>
</dl>
    </td>
  </tr>
</table>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="a1" doxytag="SoGLRenderAction::SoGLRenderAction" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> SoGLRenderAction::SoGLRenderAction           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classSbViewportRegion.html">SbViewportRegion</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>viewportregion</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Constructor. Sets up the render action for rendering within the given <em>viewportregion</em>.     </td>
  </tr>
</table>
<a class="anchor" name="a2" doxytag="SoGLRenderAction::~SoGLRenderAction" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> SoGLRenderAction::~<a class="el" href="classSoGLRenderAction.html">SoGLRenderAction</a>           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Destructor, frees up all internal resources for action instance.     </td>
  </tr>
</table>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="a0" doxytag="SoGLRenderAction::getTypeId" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classSoType.html">SoType</a> SoGLRenderAction::getTypeId           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the type identification of an action derived from a class inheriting <a class="el" href="classSoAction.html">SoAction</a>. This is used for run-time type checking and "downward" casting.<p>
Usage example:<p>
<pre><div class="fragment">  <span class="keywordtype">void</span> bar(<a class="code" href="classSoAction.html">SoAction</a> * action)
  {
    <span class="keywordflow">if</span> (action-&gt;<a class="code" href="classSoAction.html#a1">getTypeId</a>() == <a class="code" href="classSoGLRenderAction.html#e0">SoGLRenderAction::getClassTypeId</a>()) {
      <span class="comment">// safe downward cast, know the type</span>
      <a class="code" href="classSoGLRenderAction.html">SoGLRenderAction</a> * glrender = (<a class="code" href="classSoGLRenderAction.html">SoGLRenderAction</a> *)action;
    }
    <span class="keywordflow">return</span>; <span class="comment">// ignore if not renderaction</span>
  }
</div></pre><p>
For application programmers wanting to extend the library with new actions: this method needs to be overridden in <em>all</em> subclasses. This is typically done as part of setting up the full type system for extension classes, which is usually accomplished by using the pre-defined macros available through Inventor/nodes/SoSubAction.h: SO_ACTION_SOURCE, SO_ACTION_INIT_CLASS and SO_ACTION_CONSTRUCTOR.<p>
For more information on writing Coin extensions, see the <a class="el" href="classSoAction.html">SoAction</a> class documentation. 
<p>
Implements <a class="el" href="classSoAction.html#a1">SoAction</a>.
<p>
Reimplemented in <a class="el" href="classSoBoxHighlightRenderAction.html#a0">SoBoxHighlightRenderAction</a>, and <a class="el" href="classSoLineHighlightRenderAction.html#a0">SoLineHighlightRenderAction</a>.    </td>
  </tr>
</table>
<a class="anchor" name="e0" doxytag="SoGLRenderAction::getClassTypeId" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classSoType.html">SoType</a> SoGLRenderAction::getClassTypeId           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the run-time type object associated with instances of this class. 
<p>
Reimplemented from <a class="el" href="classSoAction.html#e2">SoAction</a>.
<p>
Reimplemented in <a class="el" href="classSoBoxHighlightRenderAction.html#e0">SoBoxHighlightRenderAction</a>, and <a class="el" href="classSoLineHighlightRenderAction.html#e0">SoLineHighlightRenderAction</a>.    </td>
  </tr>
</table>
<a class="anchor" name="e1" doxytag="SoGLRenderAction::addMethod" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoGLRenderAction::addMethod           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classSoType.html">SoType</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>SoActionMethod&nbsp;</td>
          <td class="mdname" nowrap> <em>method</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em> 
<p>
Reimplemented in <a class="el" href="classSoBoxHighlightRenderAction.html#e1">SoBoxHighlightRenderAction</a>, and <a class="el" href="classSoLineHighlightRenderAction.html#e1">SoLineHighlightRenderAction</a>.    </td>
  </tr>
</table>
<a class="anchor" name="e2" doxytag="SoGLRenderAction::enableElement" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoGLRenderAction::enableElement           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classSoType.html">SoType</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>stackindex</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em> 
<p>
Reimplemented in <a class="el" href="classSoBoxHighlightRenderAction.html#e2">SoBoxHighlightRenderAction</a>, and <a class="el" href="classSoLineHighlightRenderAction.html#e2">SoLineHighlightRenderAction</a>.    </td>
  </tr>
</table>
<a class="anchor" name="b0" doxytag="SoGLRenderAction::getEnabledElements" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> const <a class="el" href="classSoEnabledElementsList.html">SoEnabledElementsList</a> &amp; SoGLRenderAction::getEnabledElements           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns a list of the elements used by action instances of this class upon traversal operations. 
<p>
Reimplemented from <a class="el" href="classSoAction.html#b4">SoAction</a>.
<p>
Reimplemented in <a class="el" href="classSoBoxHighlightRenderAction.html#b0">SoBoxHighlightRenderAction</a>, and <a class="el" href="classSoLineHighlightRenderAction.html#b0">SoLineHighlightRenderAction</a>.    </td>
  </tr>
</table>
<a class="anchor" name="f0" doxytag="SoGLRenderAction::getClassEnabledElements" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classSoEnabledElementsList.html">SoEnabledElementsList</a> * SoGLRenderAction::getClassEnabledElements           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static, protected]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em><p>
This method not available in the original OIV API, see <a class="el" href="SoSubAction_8h.html">SoSubAction.h</a> for explanation. 
<p>
Reimplemented from <a class="el" href="classSoAction.html#f0">SoAction</a>.
<p>
Reimplemented in <a class="el" href="classSoBoxHighlightRenderAction.html#f0">SoBoxHighlightRenderAction</a>, and <a class="el" href="classSoLineHighlightRenderAction.html#f0">SoLineHighlightRenderAction</a>.    </td>
  </tr>
</table>
<a class="anchor" name="f1" doxytag="SoGLRenderAction::getClassActionMethods" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classSoActionMethodList.html">SoActionMethodList</a> * SoGLRenderAction::getClassActionMethods           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static, protected]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em><p>
This method not available in the original OIV API, see <a class="el" href="SoSubAction_8h.html">SoSubAction.h</a> for explanation. 
<p>
Reimplemented from <a class="el" href="classSoAction.html#f1">SoAction</a>.
<p>
Reimplemented in <a class="el" href="classSoBoxHighlightRenderAction.html#f1">SoBoxHighlightRenderAction</a>, and <a class="el" href="classSoLineHighlightRenderAction.html#f1">SoLineHighlightRenderAction</a>.    </td>
  </tr>
</table>
<a class="anchor" name="e3" doxytag="SoGLRenderAction::initClass" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoGLRenderAction::initClass           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initializes the run-time type system for this class, and sets up the enabled elements and action method list. 
<p>
Reimplemented from <a class="el" href="classSoAction.html#e0">SoAction</a>.
<p>
Reimplemented in <a class="el" href="classSoBoxHighlightRenderAction.html#e3">SoBoxHighlightRenderAction</a>, and <a class="el" href="classSoLineHighlightRenderAction.html#e3">SoLineHighlightRenderAction</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a3" doxytag="SoGLRenderAction::setViewportRegion" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoGLRenderAction::setViewportRegion           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classSbViewportRegion.html">SbViewportRegion</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>newregion</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets the viewport region for rendering. This will then override the region passed in with the constructor.     </td>
  </tr>
</table>
<a class="anchor" name="a4" doxytag="SoGLRenderAction::getViewportRegion" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> const <a class="el" href="classSbViewportRegion.html">SbViewportRegion</a> &amp; SoGLRenderAction::getViewportRegion           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the viewport region for the rendering action.     </td>
  </tr>
</table>
<a class="anchor" name="a5" doxytag="SoGLRenderAction::setUpdateArea" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoGLRenderAction::setUpdateArea           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classSbVec2f.html">SbVec2f</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>origin</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>const <a class="el" href="classSbVec2f.html">SbVec2f</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>size</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets the area of the OpenGL context canvas we should render into.<p>
The coordinates for <em>origin</em> and <em>size</em> should be normalized to be within [0.0, 1.0]. The default settings are &lt;0.0, 0.0&gt; for the <em>origin</em> and &lt;1.0, 1.0&gt; for the <em>size</em>, using the full size of the rendering canvas.     </td>
  </tr>
</table>
<a class="anchor" name="a6" doxytag="SoGLRenderAction::getUpdateArea" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoGLRenderAction::getUpdateArea           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classSbVec2f.html">SbVec2f</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>origin</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classSbVec2f.html">SbVec2f</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>size</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns information about the area of the rendering context window to be updated.     </td>
  </tr>
</table>
<a class="anchor" name="a7" doxytag="SoGLRenderAction::setAbortCallback" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoGLRenderAction::setAbortCallback           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classSoGLRenderAction.html#w0">SoGLRenderAbortCB</a> *const&nbsp;</td>
          <td class="mdname" nowrap> <em>func</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>void *const&nbsp;</td>
          <td class="mdname" nowrap> <em>userdata</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets the abort callback. The abort callback is called by the action for each node during traversal to check for abort conditions.<p>
The callback method should return one of the <a class="el" href="classSoGLRenderAction.html#w17">SoGLRenderAction::AbortCode</a> enum values to indicate how the action should proceed further.<p>
Since the client SoGLRenderAbortCB callback function only has a single void* argument for the userdata, one has to do some additional work to find out which node the callback was made for. One can do this by for instance passing along the action pointer as userdata, and then call the <a class="el" href="classSoAction.html#a17">SoGLRenderAction::getCurPath()</a> method. The tail of the path will then be the last traversed node. Like this:<p>
<pre><div class="fragment">  <span class="comment">// set up so we can abort or otherwise intervene with the render</span>
  <span class="comment">// traversal:</span>
  myRenderAction-&gt;setAbortCallback(MyRenderCallback, myRenderAction);

  <span class="comment">// [...]</span>

  <a class="code" href="classSoGLRenderAction.html#w17">SoGLRenderAction::AbortCode</a>
  MyRenderCallback(<span class="keywordtype">void</span> * userdata)
  {
    <a class="code" href="classSoGLRenderAction.html">SoGLRenderAction</a> * action = (<a class="code" href="classSoGLRenderAction.html">SoGLRenderAction</a> *)userdata;
    <a class="code" href="classSoNode.html">SoNode</a> * lastnode = action-&gt;<a class="code" href="classSoAction.html#a17">getCurPath</a>()-&gt;<a class="code" href="classSoPath.html#a12">getTail</a>();

    <span class="comment">// [...]</span>
    <span class="keywordflow">return</span> <a class="code" href="classSoGLRenderAction.html#w17w12">SoGLRenderAction::CONTINUE</a>;
  }
</div></pre><p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSoGLRenderAction.html#w17">SoGLRenderAction::AbortCode</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a8" doxytag="SoGLRenderAction::setTransparencyType" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoGLRenderAction::setTransparencyType           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classSoGLRenderAction.html#w16">TransparencyType</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>type</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets the transparency rendering method for transparent objects in the scene graph.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSoGLRenderAction.html#w16">SoGLRenderAction::TransparencyType</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a9" doxytag="SoGLRenderAction::getTransparencyType" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classSoGLRenderAction.html#w16">SoGLRenderAction::TransparencyType</a> SoGLRenderAction::getTransparencyType           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the transparency rendering type.     </td>
  </tr>
</table>
<a class="anchor" name="a10" doxytag="SoGLRenderAction::setSmoothing" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoGLRenderAction::setSmoothing           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const SbBool&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>smooth</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets (or unsets) smoothing. If the smoothing flag is <code>on</code>, Coin will try to use built-in features from the OpenGL implementation to smooth the appearance of otherwise jagged borders.<p>
This is a simple (and computationally non-intensive) way of doing anti-aliasing.<p>
Default value for this flag is to be <code>off</code>.     </td>
  </tr>
</table>
<a class="anchor" name="a11" doxytag="SoGLRenderAction::isSmoothing" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> SbBool SoGLRenderAction::isSmoothing           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns whether smoothing is set or not.     </td>
  </tr>
</table>
<a class="anchor" name="a12" doxytag="SoGLRenderAction::setNumPasses" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoGLRenderAction::setNumPasses           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>num</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets the number of rendering passes. Default is 1, anything greater will enable antialiasing.     </td>
  </tr>
</table>
<a class="anchor" name="a13" doxytag="SoGLRenderAction::getNumPasses" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int SoGLRenderAction::getNumPasses           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the number of rendering passes done on updates.     </td>
  </tr>
</table>
<a class="anchor" name="a14" doxytag="SoGLRenderAction::setPassUpdate" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoGLRenderAction::setPassUpdate           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const SbBool&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>flag</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets whether each pass should render to screen or not.     </td>
  </tr>
</table>
<a class="anchor" name="a15" doxytag="SoGLRenderAction::isPassUpdate" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> SbBool SoGLRenderAction::isPassUpdate           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the value of the "show intermediate updates" flag.<p>
<dl compact><dt><b>See also:</b></dt><dd>setPassUpdate() </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a16" doxytag="SoGLRenderAction::setPassCallback" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoGLRenderAction::setPassCallback           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">SoGLRenderPassCB *const&nbsp;</td>
          <td class="mdname" nowrap> <em>func</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>void *const&nbsp;</td>
          <td class="mdname" nowrap> <em>userdata</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets the pass callback. The callback is called between each rendering pass.     </td>
  </tr>
</table>
<a class="anchor" name="a17" doxytag="SoGLRenderAction::setCacheContext" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoGLRenderAction::setCacheContext           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const uint32_t&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>context</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets the OpenGL cache context key, which is used for deciding when to share OpenGL display lists.<p>
Each SoGLRenderAction has a cache context id. This can be set using SoGLRenderAction::setCacheContext(). The cache context id must be unique, so that different texture objects and display lists are created for uncompatible GL contexts. For instance, when SoGLRenderAction traverses an <a class="el" href="classSoTexture2.html">SoTexture2</a> node, the node checks if it has a texture object created for the cache context. If not, a new texture object will be created and used when rendering.<p>
<dl compact><dt><b>See also:</b></dt><dd>SoGLCacheContextElement::getUniqueCacheContext() </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a18" doxytag="SoGLRenderAction::getCacheContext" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> uint32_t SoGLRenderAction::getCacheContext           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the cache context key for this rendering action instance.     </td>
  </tr>
</table>
<a class="anchor" name="a19" doxytag="SoGLRenderAction::addDelayedPath" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoGLRenderAction::addDelayedPath           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classSoPath.html">SoPath</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>path</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Adds a path to the list of paths to render after the current pass.     </td>
  </tr>
</table>
<a class="anchor" name="a20" doxytag="SoGLRenderAction::isRenderingDelayedPaths" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> SbBool SoGLRenderAction::isRenderingDelayedPaths           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns a flag indicating whether or not we are currently rendering from the list of delayed paths of the scene graph.     </td>
  </tr>
</table>
<a class="anchor" name="a21" doxytag="SoGLRenderAction::handleTransparency" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> SbBool SoGLRenderAction::handleTransparency           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">SbBool&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>istransparent</em> = <code>0</code>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Used by shape nodes or others which need to know whether or not they should immediately render themselves or if they should wait until the next pass.     </td>
  </tr>
</table>
<a class="anchor" name="a22" doxytag="SoGLRenderAction::getCurPass" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int SoGLRenderAction::getCurPass           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the number of the current rendering pass.     </td>
  </tr>
</table>
<a class="anchor" name="a23" doxytag="SoGLRenderAction::abortNow" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> SbBool SoGLRenderAction::abortNow           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns <code>TRUE</code> if the render action should abort now based on user callback.<p>
<dl compact><dt><b>See also:</b></dt><dd>setAbortCallback() </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a24" doxytag="SoGLRenderAction::setRenderingIsRemote" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoGLRenderAction::setRenderingIsRemote           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">SbBool&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>isremote</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Let SoGLRenderAction instance know if application is running on the local machine or if the rendering instructions are sent over the network.<p>
The flag is used to optimize rendering. For instance should the displaylist caching strategy be influenced by this flag to be more aggressive with the caching when rendering instructions are passed over the network.<p>
Default value is <code>FALSE</code>. The value of the flag will not be changed internally from the Coin library code, as it is meant to be controlled from client code -- typically from the SoQt / SoXt / SoWin / SoGtk libraries.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSoGLRenderAction.html#a25">getRenderingIsRemote()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a25" doxytag="SoGLRenderAction::getRenderingIsRemote" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> SbBool SoGLRenderAction::getRenderingIsRemote           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns whether or not the application is running remotely.<p>
<dl compact><dt><b>See also:</b></dt><dd>setRenderingIsRemote() </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a26" doxytag="SoGLRenderAction::invalidateState" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoGLRenderAction::invalidateState           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Invalidates the state, forcing it to be recreated at the next apply() invocation. 
<p>
Reimplemented from <a class="el" href="classSoAction.html#a7">SoAction</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a27" doxytag="SoGLRenderAction::addPreRenderCallback" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoGLRenderAction::addPreRenderCallback           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">SoGLPreRenderCB *&nbsp;</td>
          <td class="mdname" nowrap> <em>func</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>userdata</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Adds a callback which is invoked right before the scene graph traversal starts. All necessary GL initialization is then done (e.g. the viewport is correctly set), and this callback can be useful to, for instance, clear the viewport before rendering, or draw a bitmap in the background before rendering etc.<p>
The callback is only invoked once (before the first rendering pass) when multi pass rendering is enabled.<p>
Please note that <a class="el" href="classSoSceneManager.html">SoSceneManager</a> usually adds a callback to clear the GL buffers in SoSceneManager::render(). So, if you plan to for instance draw an image in the color buffer using this callback, you should make sure that the scene manager doesn't clear the buffer. This can be done either by calling SoSceneManager::render() with both arguments FALSE, or, if you're using one of our GUI toolkits (SoXt/SoQt/SoGtk/SoWin), call setClearBeforeRender() on the viewer.<p>
This method is an extension versus the Open Inventor API.<p>
<dl compact><dt><b>See also:</b></dt><dd>removePreRenderCallback(). </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a28" doxytag="SoGLRenderAction::removePreRenderCallback" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoGLRenderAction::removePreRenderCallback           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">SoGLPreRenderCB *&nbsp;</td>
          <td class="mdname" nowrap> <em>func</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>userdata</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Removed a callback added with the addPreRenderCallback() method.<p>
This method is an extension versus the Open Inventor API.<p>
<dl compact><dt><b>See also:</b></dt><dd>addPreRenderCallback() </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a29" doxytag="SoGLRenderAction::setSortedLayersNumPasses" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoGLRenderAction::setSortedLayersNumPasses           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>num</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets the number of passes to render in <a class="el" href="classSoGLRenderAction.html#w16w11">SoGLRenderAction::SORTED_LAYERS_BLEND</a> mode. Default number of passes is 4. This number can also be adjusted by setting the <code>COIN_NUM_SORTED_LAYERS_PASSES</code> or <code>OIV_NUM_SORTED_LAYERS_PASSES</code> environment variable.     </td>
  </tr>
</table>
<a class="anchor" name="a30" doxytag="SoGLRenderAction::getSortedLayersNumPasses" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int SoGLRenderAction::getSortedLayersNumPasses           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the number of passes to render when in <a class="el" href="classSoGLRenderAction.html#w16w11">SoGLRenderAction::SORTED_LAYERS_BLEND</a> mode.     </td>
  </tr>
</table>
<a class="anchor" name="b1" doxytag="SoGLRenderAction::beginTraversal" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoGLRenderAction::beginTraversal           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classSoNode.html">SoNode</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>node</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [protected, virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This virtual method is called from SoAction::apply(), and is the entry point for the actual scenegraph traversal.<p>
It can be overridden to initialize the action at traversal start, for specific initializations in the action subclasses inheriting <a class="el" href="classSoAction.html">SoAction</a>.<p>
Default method just calls traverse(), which any overridden implementation of the method must do too (or call SoAction::beginTraversal()) to trigger the scenegraph traversal. 
<p>
Reimplemented from <a class="el" href="classSoAction.html#b1">SoAction</a>.    </td>
  </tr>
</table>
<a class="anchor" name="b2" doxytag="SoGLRenderAction::endTraversal" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoGLRenderAction::endTraversal           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classSoNode.html">SoNode</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>node</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [protected, virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This virtual method can be overridden to execute code after the scene graph traversal. Default method does nothing. 
<p>
Reimplemented from <a class="el" href="classSoAction.html#b2">SoAction</a>.    </td>
  </tr>
</table>
<hr>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="SoGLRenderAction_8h-source.html">SoGLRenderAction.h</a><li>SoGLRenderAction.cpp</ul>
<hr noshade>
<p align="right">Copyright &copy 1998-2004 by <a href="http://www.sim.no">Systems in Motion AS</a>. All rights reserved.</p>
<address style="align: right;"><small>
Generated on Mon Oct 18 01:24:53 2004 for Coin by <a href="http://www.doxygen.org/index.html">Doxygen.</a> 1.3.7</small></address>
</body>
</html>
