<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SoTextureCombine class Reference</title>
<link href="stylesheet.css" rel="stylesheet" type="text/css">
</head><body><table width="100%">
<tr>
  <td>
    <img src="Coin_logo.png" alt="Coin Logo">
  </td>
  <td align="right">
    <a href="http://www.sim.no">http://www.sim.no</a><br>
    <a href="http://www.coin3d.org/">http://www.coin3d.org</a>
  </td>
</tr>
</table>
<hr noshade>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>SoTextureCombine Class Reference<br>
<small>
[<a class="el" href="group__nodes.html">Nodes</a>]</small>
</h1><code>#include &lt;<a class="el" href="SoTextureCombine_8h-source.html">Inventor/nodes/SoTextureCombine.h</a>&gt;</code>
<p>
<p>Inheritance diagram for SoTextureCombine:
<p><center><img src="classSoTextureCombine.png" usemap="#SoTextureCombine_map" border="0" alt=""></center>
<map name="SoTextureCombine_map">
<area href="classSoNode.html" alt="SoNode" shape="rect" coords="0,112,118,136">
<area href="classSoFieldContainer.html" alt="SoFieldContainer" shape="rect" coords="0,56,118,80">
<area href="classSoBase.html" alt="SoBase" shape="rect" coords="0,0,118,24">
</map>
<a href="classSoTextureCombine-members.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>
The SoTextureCombine class is a node for setting texture combine functions. 
<p>
This node is more or less an exact mapping of the OpenGL ARB_texture_env_combine extension (included in OpenGL in OpenGL v1.3). See <a href="http://oss.sgi.com/projects/ogl-sample/registry/ARB/texture_env_combine.txt">http://oss.sgi.com/projects/ogl-sample/registry/ARB/texture_env_combine.txt</a> for more information about this extension.<p>
Basically this node lets you specify up to three sources, and a function to combine those sources. In addition to the function, it's possible to apply simple operands on the sources. In the documentation below, the sources will be called Arg0, Arg1, and Arg2, just like in the ARB_texture_env_mode specification.<p>
It's possible to specify both a color and an alpha operation.<p>
This node has many fields, but usually it is sufficient to set only one or very few fields. The selected operation decides which values you need to set. One common example is to add a light map to textured geometry. A lightmap can look like this:<p>
<center> <div align="center">
<img src="http://doc.coin3d.org/images/Coin/nodes/lightmap.jpg" alt="lightmap.jpg">
</div>
 </center><p>
The example below just shows how to apply the lightmap to a cube, with one light source on each side of the cube. Usually the texture coordinates are calculated so that a spot light or a point light is simulated.<p>
<pre><div class="fragment">

  Texture2 { filename "wood.jpg" }
  
  Switch {
    whichChild -3   # use to toggle lightmap on/off
    TextureUnit {
      unit 1
    }
    TextureCombine {
      rgbOperation ADD_SIGNED
      rgbSource [PREVIOUS, TEXTURE]
      rgbOperand [SRC_COLOR, SRC_COLOR ]
      alphaOperation REPLACE
      alphaSource [TEXTURE]
      alphaOperand [SRC_ALPHA]
    }
    Texture2 { filename "lightmap.jpg" }
    TextureUnit { unit 0 }
  }
  Cube { }

  </div></pre><p>
The scene above in a viewer:<p>
<center> <div align="center">
<img src="http://doc.coin3d.org/images/Coin/nodes/lightmap_screenshot.png" alt="lightmap_screenshot.png">
</div>
 </center><p>
In addition to the functions you can set in rgbOperation (or alphaOperation), it's possible to create more complex texture functions by combining two textures that have already been combined. You can use the <a class="el" href="classSoSceneTexture2.html">SoSceneTexture2</a> node to create those textures. Below is an example that shows how to implement Arg0*Arg1 + Arg2*Arg0, where Arg0 = texture1 RGB, Arg1 = texture2 RGB, Arg2 = texture 2 alpha:<p>
<pre><div class="fragment"> 

  ShapeHints { vertexOrdering COUNTERCLOCKWISE shapeType SOLID }

  Separator {
    SceneTexture2 {
      size 256 256
      transparencyFunction NONE
      scene Separator {
        OrthographicCamera {
          height 2
          aspectRatio 1
          position 0 0 1
          viewportMapping LEAVE_ALONE
        }
        LightModel { model BASE_COLOR }
        Coordinate3 {
          point [ -1 -1 0, 1 -1 0, 1 1 0, -1 1 0 ] 
        }
        DEF texture1 Texture2 { filename "texture1.png" }
        TextureUnit { unit 1 }
        TextureCombine {
          rgbOperation MODULATE
          rgbSource [ PREVIOUS, TEXTURE ]
          rgbOperand [ SRC_COLOR, SRC_COLOR ]
          alphaOperation REPLACE
          alphaSource [TEXTURE]
          alphaOperand [ SRC_ALPHA ]
        }
        DEF texture2 Texture2 { filename "texture2_with_alpha.png" }
        TextureCoordinate2 {
          point [0 0, 1 0, 1 1, 0 1]
        }
        FaceSet { numVertices 4 }
      }
    }
    TextureUnit { unit 1 }
    TextureCombine {
      rgbOperation ADD
      rgbSource [ PREVIOUS, TEXTURE ]
      rgbOperand [ SRC_COLOR, SRC_COLOR ]
      alphaOperation REPLACE
      alphaSource [TEXTURE]
      alphaOperand [ SRC_ALPHA ]
    }
    SceneTexture2 {
      size 256 256
      transparencyFunction NONE
      scene Separator {
        OrthographicCamera {
          height 2
          aspectRatio 1
          position 0 0 1
          viewportMapping LEAVE_ALONE
        }
        LightModel { model BASE_COLOR }
        Coordinate3 {
          point [ -1 -1 0, 1 -1 0, 1 1 0, -1 1 0 ] 
        }
        USE texture1
        TextureUnit { unit 1 }
        TextureCombine {
          rgbOperation MODULATE
          rgbSource [ PREVIOUS, TEXTURE ]
          rgbOperand [ SRC_COLOR, SRC_ALPHA ]
          alphaOperation REPLACE
          alphaSource [TEXTURE]
          alphaOperand [ SRC_ALPHA ]
        }
        USE texture2
        TextureCoordinate2 {
          point [0 0, 1 0, 1 1, 0 1]
        }
        FaceSet { numVertices 4 }
      }
    }
    # map resulting texture onto a Cube
    Cube { }
  }
  </div></pre><p>
It should be possible to create almost any kind of texture function using this scheme, at the cost of extra texture memory usage (the intermediate textures), of course.<p>
<dl compact><dt><b>Since:</b></dt><dd>Coin 2.3 </dd></dl>

<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>enum &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoTextureCombine.html#w16">Source</a> { <a class="el" href="classSoTextureCombine.html#w16w0">PRIMARY_COLOR</a> =  SoTextureCombineElement::PRIMARY_COLOR, 
<a class="el" href="classSoTextureCombine.html#w16w1">TEXTURE</a> =  SoTextureCombineElement::TEXTURE, 
<a class="el" href="classSoTextureCombine.html#w16w2">CONSTANT</a> =  SoTextureCombineElement::CONSTANT, 
<a class="el" href="classSoTextureCombine.html#w16w3">PREVIOUS</a> =  SoTextureCombineElement::PREVIOUS
 }</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>enum &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoTextureCombine.html#w17">Operand</a> { <a class="el" href="classSoTextureCombine.html#w17w4">SRC_COLOR</a> =  SoTextureCombineElement::SRC_COLOR, 
<a class="el" href="classSoTextureCombine.html#w17w5">ONE_MINUS_SRC_COLOR</a> =  SoTextureCombineElement::ONE_MINUS_SRC_COLOR, 
<a class="el" href="classSoTextureCombine.html#w17w6">SRC_ALPHA</a> =  SoTextureCombineElement::SRC_ALPHA, 
<a class="el" href="classSoTextureCombine.html#w17w7">ONE_MINUS_SRC_ALPHA</a> =  SoTextureCombineElement::ONE_MINUS_SRC_ALPHA
 }</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>enum &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoTextureCombine.html#w18">Operation</a> { <br>
&nbsp;&nbsp;<a class="el" href="classSoTextureCombine.html#w18w8">REPLACE</a> =  SoTextureCombineElement::REPLACE, 
<a class="el" href="classSoTextureCombine.html#w18w9">MODULATE</a> =  SoTextureCombineElement::MODULATE, 
<a class="el" href="classSoTextureCombine.html#w18w10">ADD</a> =  SoTextureCombineElement::ADD, 
<a class="el" href="classSoTextureCombine.html#w18w11">ADD_SIGNED</a> =  SoTextureCombineElement::ADD_SIGNED, 
<br>
&nbsp;&nbsp;<a class="el" href="classSoTextureCombine.html#w18w12">SUBTRACT</a> =  SoTextureCombineElement::SUBTRACT, 
<a class="el" href="classSoTextureCombine.html#w18w13">INTERPOLATE</a> =  SoTextureCombineElement::INTERPOLATE, 
<a class="el" href="classSoTextureCombine.html#w18w14">DOT3_RGB</a> =  SoTextureCombineElement::DOT3_RGB, 
<a class="el" href="classSoTextureCombine.html#w18w15">DOT3_RGBA</a> =  SoTextureCombineElement::DOT3_RGBA
<br>
 }</td></tr>

<tr><td colspan=2><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>virtual <a class="el" href="classSoType.html">SoType</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoTextureCombine.html#a0">getTypeId</a> (void) const</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoTextureCombine.html#a1">SoTextureCombine</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoTextureCombine.html#a2">doAction</a> (<a class="el" href="classSoAction.html">SoAction</a> *action)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoTextureCombine.html#a3">callback</a> (<a class="el" href="classSoCallbackAction.html">SoCallbackAction</a> *action)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoTextureCombine.html#a4">GLRender</a> (<a class="el" href="classSoGLRenderAction.html">SoGLRenderAction</a> *action)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoTextureCombine.html#a5">pick</a> (<a class="el" href="classSoPickAction.html">SoPickAction</a> *action)</td></tr>

<tr><td colspan=2><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="classSoType.html">SoType</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoTextureCombine.html#e0">getClassTypeId</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoTextureCombine.html#e1">initClass</a> (void)</td></tr>

<tr><td colspan=2><br><h2>Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="o0" doxytag="SoTextureCombine::rgbSource" ></a>
<a class="el" href="classSoMFEnum.html">SoMFEnum</a>&nbsp;</td><td class="memItemRight" valign=bottom><b>rgbSource</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="o1" doxytag="SoTextureCombine::alphaSource" ></a>
<a class="el" href="classSoMFEnum.html">SoMFEnum</a>&nbsp;</td><td class="memItemRight" valign=bottom><b>alphaSource</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="o2" doxytag="SoTextureCombine::rgbOperand" ></a>
<a class="el" href="classSoMFEnum.html">SoMFEnum</a>&nbsp;</td><td class="memItemRight" valign=bottom><b>rgbOperand</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="o3" doxytag="SoTextureCombine::alphaOperand" ></a>
<a class="el" href="classSoMFEnum.html">SoMFEnum</a>&nbsp;</td><td class="memItemRight" valign=bottom><b>alphaOperand</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="o4" doxytag="SoTextureCombine::rgbOperation" ></a>
<a class="el" href="classSoSFEnum.html">SoSFEnum</a>&nbsp;</td><td class="memItemRight" valign=bottom><b>rgbOperation</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="o5" doxytag="SoTextureCombine::alphaOperation" ></a>
<a class="el" href="classSoSFEnum.html">SoSFEnum</a>&nbsp;</td><td class="memItemRight" valign=bottom><b>alphaOperation</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="o6" doxytag="SoTextureCombine::rgbScale" ></a>
<a class="el" href="classSoSFFloat.html">SoSFFloat</a>&nbsp;</td><td class="memItemRight" valign=bottom><b>rgbScale</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="o7" doxytag="SoTextureCombine::alphaScale" ></a>
<a class="el" href="classSoSFFloat.html">SoSFFloat</a>&nbsp;</td><td class="memItemRight" valign=bottom><b>alphaScale</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="o8" doxytag="SoTextureCombine::constantColor" ></a>
<a class="el" href="classSoSFVec4f.html">SoSFVec4f</a>&nbsp;</td><td class="memItemRight" valign=bottom><b>constantColor</b></td></tr>

<tr><td colspan=2><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>virtual const <a class="el" href="classSoFieldData.html">SoFieldData</a> *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoTextureCombine.html#b0">getFieldData</a> (void) const</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoTextureCombine.html#b1">~SoTextureCombine</a> ()</td></tr>

<tr><td colspan=2><br><h2>Static Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>const <a class="el" href="classSoFieldData.html">SoFieldData</a> **&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoTextureCombine.html#f0">getFieldDataPtr</a> (void)</td></tr>

</table>
<hr><h2>Member Enumeration Documentation</h2>
<a class="anchor" name="w16" doxytag="SoTextureCombine::Source" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> enum <a class="el" href="classSoTextureCombine.html#w16">SoTextureCombine::Source</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
For enumerating combiner sources. <dl compact><dt><b>Enumeration values: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="anchor" name="w16w0" doxytag="PRIMARY_COLOR" ></a>PRIMARY_COLOR</em>&nbsp;</td><td>
Choose primary color as source. </td></tr>
<tr><td valign=top><em><a class="anchor" name="w16w1" doxytag="TEXTURE" ></a>TEXTURE</em>&nbsp;</td><td>
Choose texture as source. </td></tr>
<tr><td valign=top><em><a class="anchor" name="w16w2" doxytag="CONSTANT" ></a>CONSTANT</em>&nbsp;</td><td>
Choose the constantColor field as source. </td></tr>
<tr><td valign=top><em><a class="anchor" name="w16w3" doxytag="PREVIOUS" ></a>PREVIOUS</em>&nbsp;</td><td>
Choose the previous unit's texture as source. </td></tr>
</table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="w17" doxytag="SoTextureCombine::Operand" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> enum <a class="el" href="classSoTextureCombine.html#w17">SoTextureCombine::Operand</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
For enumerating source operands. <dl compact><dt><b>Enumeration values: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="anchor" name="w17w4" doxytag="SRC_COLOR" ></a>SRC_COLOR</em>&nbsp;</td><td>
Use the source color as operand. </td></tr>
<tr><td valign=top><em><a class="anchor" name="w17w5" doxytag="ONE_MINUS_SRC_COLOR" ></a>ONE_MINUS_SRC_COLOR</em>&nbsp;</td><td>
Use one minus source color as operand. </td></tr>
<tr><td valign=top><em><a class="anchor" name="w17w6" doxytag="SRC_ALPHA" ></a>SRC_ALPHA</em>&nbsp;</td><td>
Use the source alpha as operand. </td></tr>
<tr><td valign=top><em><a class="anchor" name="w17w7" doxytag="ONE_MINUS_SRC_ALPHA" ></a>ONE_MINUS_SRC_ALPHA</em>&nbsp;</td><td>
Use one minus source alpha as operand. </td></tr>
</table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="w18" doxytag="SoTextureCombine::Operation" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> enum <a class="el" href="classSoTextureCombine.html#w18">SoTextureCombine::Operation</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
For enumerating combiner operations/functions. <dl compact><dt><b>Enumeration values: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="anchor" name="w18w8" doxytag="REPLACE" ></a>REPLACE</em>&nbsp;</td><td>
dst = Arg0 </td></tr>
<tr><td valign=top><em><a class="anchor" name="w18w9" doxytag="MODULATE" ></a>MODULATE</em>&nbsp;</td><td>
dst = Arg0 * Arg1 </td></tr>
<tr><td valign=top><em><a class="anchor" name="w18w10" doxytag="ADD" ></a>ADD</em>&nbsp;</td><td>
dst = Arg0 + Arg1 </td></tr>
<tr><td valign=top><em><a class="anchor" name="w18w11" doxytag="ADD_SIGNED" ></a>ADD_SIGNED</em>&nbsp;</td><td>
dst = Arg0 + Arg1 - 0.5 </td></tr>
<tr><td valign=top><em><a class="anchor" name="w18w12" doxytag="SUBTRACT" ></a>SUBTRACT</em>&nbsp;</td><td>
dst = Arg0 - Arg1 </td></tr>
<tr><td valign=top><em><a class="anchor" name="w18w13" doxytag="INTERPOLATE" ></a>INTERPOLATE</em>&nbsp;</td><td>
dst = Arg0 * (Arg2) + Arg1 * (1-Arg2) </td></tr>
<tr><td valign=top><em><a class="anchor" name="w18w14" doxytag="DOT3_RGB" ></a>DOT3_RGB</em>&nbsp;</td><td>
Dot product of Arg0 and Arg1 </td></tr>
<tr><td valign=top><em><a class="anchor" name="w18w15" doxytag="DOT3_RGBA" ></a>DOT3_RGBA</em>&nbsp;</td><td>
Dot product (including alpha) of Arg0 and Arg1 </td></tr>
</table>
</dl>
    </td>
  </tr>
</table>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="a1" doxytag="SoTextureCombine::SoTextureCombine" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> SoTextureCombine::SoTextureCombine           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Constructor.     </td>
  </tr>
</table>
<a class="anchor" name="b1" doxytag="SoTextureCombine::~SoTextureCombine" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> SoTextureCombine::~<a class="el" href="classSoTextureCombine.html">SoTextureCombine</a>           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [protected, virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Destructor.     </td>
  </tr>
</table>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="e0" doxytag="SoTextureCombine::getClassTypeId" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classSoType.html">SoType</a> SoTextureCombine::getClassTypeId           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
SoTextureCombine::constantColor<p>
The constant color (when CONSTANT is used as source). Default value is (1,1,1,1). 
<p>
Reimplemented from <a class="el" href="classSoNode.html#e1">SoNode</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a0" doxytag="SoTextureCombine::getTypeId" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classSoType.html">SoType</a> SoTextureCombine::getTypeId           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the type identification of an object derived from a class inheriting <a class="el" href="classSoBase.html">SoBase</a>. This is used for run-time type checking and "downward" casting.<p>
Usage example:<p>
<pre><div class="fragment">  <span class="keywordtype">void</span> foo(<a class="code" href="classSoNode.html">SoNode</a> * node)
  {
    <span class="keywordflow">if</span> (node-&gt;<a class="code" href="classSoBase.html#a5">getTypeId</a>() == <a class="code" href="classSoFile.html#e0">SoFile::getClassTypeId</a>()) {
      <a class="code" href="classSoFile.html">SoFile</a> * filenode = (<a class="code" href="classSoFile.html">SoFile</a> *)node;  <span class="comment">// safe downward cast, knows the type</span>
<span class="comment"></span>    }
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (node-&gt;<a class="code" href="classSoBase.html#a5">getTypeId</a>().isOfType(SoGroup::getClassTypeId())) {
      <a class="code" href="classSoGroup.html">SoGroup</a> * group = (<a class="code" href="classSoGroup.html">SoGroup</a> *)node;  <span class="comment">// safe downward cast, knows the type</span>
<span class="comment"></span>    }
  }
</div></pre><p>
For application programmers wanting to extend the library with new nodes, engines, nodekits, draggers or others: this method needs to be overridden in <em>all</em> subclasses. This is typically done as part of setting up the full type system for extension classes, which is usually accomplished by using the pre-defined macros available through for instance Inventor/nodes/SoSubNode.h (SO_NODE_INIT_CLASS and SO_NODE_CONSTRUCTOR for node classes), Inventor/engines/SoSubEngine.h (for engine classes) and so on.<p>
For more information on writing Coin extensions, see the class documentation of the toplevel superclasses for the various class groups. 
<p>
Implements <a class="el" href="classSoBase.html#a5">SoBase</a>.    </td>
  </tr>
</table>
<a class="anchor" name="f0" doxytag="SoTextureCombine::getFieldDataPtr" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> const <a class="el" href="classSoFieldData.html">SoFieldData</a> ** SoTextureCombine::getFieldDataPtr           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static, protected]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em> 
<p>
Reimplemented from <a class="el" href="classSoNode.html#f0">SoNode</a>.    </td>
  </tr>
</table>
<a class="anchor" name="b0" doxytag="SoTextureCombine::getFieldData" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> const <a class="el" href="classSoFieldData.html">SoFieldData</a> * SoTextureCombine::getFieldData           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns a pointer to the class-wide field data storage object for this instance. If no fields are present, returns <code>NULL</code>. 
<p>
Reimplemented from <a class="el" href="classSoFieldContainer.html#a21">SoFieldContainer</a>.    </td>
  </tr>
</table>
<a class="anchor" name="e1" doxytag="SoTextureCombine::initClass" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoTextureCombine::initClass           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets up initialization for data common to all instances of this class, like submitting necessary information to the Coin type system. 
<p>
Reimplemented from <a class="el" href="classSoNode.html#e4">SoNode</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a2" doxytag="SoTextureCombine::doAction" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoTextureCombine::doAction           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classSoAction.html">SoAction</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>action</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function performs the typical operation of a node for any action. 
<p>
Reimplemented from <a class="el" href="classSoNode.html#a6">SoNode</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a3" doxytag="SoTextureCombine::callback" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoTextureCombine::callback           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classSoCallbackAction.html">SoCallbackAction</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>action</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Action method for <a class="el" href="classSoCallbackAction.html">SoCallbackAction</a>.<p>
Simply updates the state according to how the node behaves for the render action, so the application programmer can use the <a class="el" href="classSoCallbackAction.html">SoCallbackAction</a> for extracting information about the scene graph. 
<p>
Reimplemented from <a class="el" href="classSoNode.html#a11">SoNode</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a4" doxytag="SoTextureCombine::GLRender" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoTextureCombine::GLRender           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classSoGLRenderAction.html">SoGLRenderAction</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>action</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Action method for the <a class="el" href="classSoGLRenderAction.html">SoGLRenderAction</a>.<p>
This is called during rendering traversals. Nodes influencing the rendering state in any way or who wants to throw geometry primitives at OpenGL overrides this method. 
<p>
Reimplemented from <a class="el" href="classSoNode.html#a7">SoNode</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a5" doxytag="SoTextureCombine::pick" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoTextureCombine::pick           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classSoPickAction.html">SoPickAction</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>action</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Action method for <a class="el" href="classSoPickAction.html">SoPickAction</a>.<p>
Does common processing for <a class="el" href="classSoPickAction.html">SoPickAction</a> <em>action</em> instances. 
<p>
Reimplemented from <a class="el" href="classSoNode.html#a15">SoNode</a>.    </td>
  </tr>
</table>
<hr>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="SoTextureCombine_8h-source.html">SoTextureCombine.h</a><li>SoTextureCombine.cpp</ul>
<hr noshade>
<p align="right">Copyright &copy 1998-2004 by <a href="http://www.sim.no">Systems in Motion AS</a>. All rights reserved.</p>
<address style="align: right;"><small>
Generated on Mon Oct 18 01:25:53 2004 for Coin by <a href="http://www.doxygen.org/index.html">Doxygen.</a> 1.3.7</small></address>
</body>
</html>
