<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>Complex Behaviour</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link href="tutorial.css" rel="stylesheet" type="text/css">
</head>

<body>
<h1>Studierstube scripting mentor</h1>
<h3>Complex Behavior</h3>
<p class="navbar">&lt;<a href="content2.html">prev</a>] - [<a href="index.html">up</a>] 
  - [<a href="extending.html">next</a>&gt;</p>
<p>With the behavior and interaction techniques discussed so far, fairly complex 
  applications can already be realized by scripting. However, these applications 
  are usually stateless, or have their state tightly coupled to the state of their 
  user interface components. For applications that advance through a series of 
  states, like presentations and story-based applications, Studierstube provides 
  a helper class that supports the control of an application based on the state 
  it is currently in.</p>
<p>The <code>SoStateEngine</code>* node encapsulates a hierarchical finite state 
  machine (HFSM), which is defined in an external XML file. Events can be routed 
  into the state machine to trigger state changes, and the state machine wil output 
  a list of states that are currently active. Events and states are simply string 
  tokens, containing the id of the state or event they are referencing.</p>
<p>The XML syntax for describing the state machine knows four elements: <code>story</code>, 
  <code>scene</code>, <code>concurrentScene</code> and <code>transition</code>. 
  The <code>story</code> element is just a wrapper for the state engine definition, 
  and doesn't take any attributes. The <code>scene</code> element contains a <code>name</code> 
  attribute, identifying the state, and an initial flag indicating if it is the 
  initial substate of its superstate (or the story if at the top level). For hierarchical 
  state machines, states can contain other states. More interestingly, a state 
  can contain multiple concurrent regions defined by the the <code>concurrentScene</code> 
  element. These regions each contain an initial state, and will be active at 
  the same time. Transitions are defined by the <code>transition</code> element, 
  containing attributes for its name (<code>event</code>) and the <code>source</code> 
  and <code>target</code> scenes of the transition. Additionally, for each transition, 
  a guard can be defined. The <code>guard</code> attribute contains the name of 
  a state that has to be active for the transition to become available. With guards, 
  conditional transitions can be realized based on the current state of the overall 
  engine. An example illustrates the usage of this syntax to describe a simple 
  presentation: </p>
<pre class="source">&lt;story&gt;<br>   &lt;scene name=&quot;empty&quot; initial=&quot;true&quot;/&gt;<br>   &lt;scene name=&quot;play&quot;&gt;<br>      &lt;concurrentScene&gt;<br>         &lt;scene name=&quot;A1&quot; initial=&quot;true&quot;/&gt;<br>         &lt;scene name=&quot;A2&quot;/&gt;<br>         &lt;transition event=&quot;go&quot; source=&quot;A1&quot; target=&quot;A2&quot;/&gt;<br>      &lt;/concurrentScene&gt;<br>      &lt;concurrentScene&gt;<br>         &lt;scene name=&quot;B1&quot; initial=&quot;true&quot;/&gt;<br>         &lt;scene name=&quot;B2&quot;/&gt;<br>         &lt;transition event=&quot;move&quot; source=&quot;B1&quot; target=&quot;B2&quot; guard=&quot;A2&quot;/&gt;<br>      &lt;/concurrentScene&gt;<br>   &lt;/scene&gt;<br>   &lt;transition event=&quot;enter&quot; source=&quot;empty&quot; target=&quot;play&quot;/&gt;<br>   &lt;transition event=&quot;leave&quot; source=&quot;play&quot; target=&quot;empty&quot;/&gt;<br>&lt;/story&gt;</pre>
<p>The UML diagram of this state engine looks like this:</p>
<p><img src="images/umlsimple.gif" width="450" height="310"></p>
<p>This state engine can now be used to control your application with an <code>SoStateEngine</code>* 
  engine. The file format for SoStateEngine is as follows:</p>
<pre class="source">SoStateEngine {
  # field name   default value # type        | description
    specFile     &quot;&quot;            # SoSFString  | the name of the file to load<br>    eventIn      &quot;&quot;            # SoSFString  | if a new value is written here, it is used as an event name in the state engine<br>  # outputs:
  # .currentState &quot;&quot;           # SoMFString  | the names of all active states in the state engine<br>  # .availableTransitions &quot;&quot;   # SoMFString  | the names of all transitions that will lead to another state<br>  # .exitStates  &quot;&quot;            # SoMFString  | the names of all states that have been left in the last transition
}</pre>
<p>For routing events to and from a SoStateEngine*, the SoConditionalTrigger* 
  is a very helpful engine: It takes strings, triggers or other values as input, 
  and outputs a string or trigger whenever a certain condition in its input is 
  met. This can be used to trigger state changes (by converting a trigger into 
  a string routed into the state engine), or to trigger behaviors in the application 
  when entering a certain state (by comparing the output of the state engine to 
  a predefined value and firing a trigger whenever the condition is met). The 
  full syntax for SoConditionalTrigger* is as follows:</p>
<pre class="source">SoConditionalTrigger{
  # field name   default value # type        | description
  # these fields define the values that will trigger the output, if they match the comparison
    triggerBool                # SoMFBool 	<br>    triggerFloat               # SoMFFloat 	<br>    triggerInt                 # SoMFInt32 	<br>    triggerString              # SoMFString 	<br>    triggerNode                # SoMFNode 	
  # these fields are used to connect the input data<br>    boolIn                     # SoMFBool 	<br>    floatIn                    # SoMFFloat 	<br>    intIn                      # SoMFInt32 	<br>    stringIn                   # SoMFString 	<br>    nodeIn                     # SoMFNode 
  # other input fields<br>    comparison EQUAL           # SoSFEnum    | each *In field is compared to its matching trigger* field with comparison
                               #             | (EQUAL | LESS_THAN | GREATER_THAN | LESS_OR_EQUAL | GREATER_OR_EQUAL)<br>    triggerIn                  # SoSFTrigger | pass-through trigger input<br>    token      &quot;&quot;              # SoSFString  | if the comparison matches, this value is copied to .tokenOut<br>  # outputs
  # .trigger                   # will fire when comparison becomes TRUE<br>  # .tokenOut                  # will be set to token when comparison becomes true<br>  # .boolOut                   # current value of the comparison
}</pre>
<p>An example using the above state engine definition and two SoConditionalTriggers:</p>
<pre class="source">&nbsp;</pre>
<h4>Context sensitive traversal</h4>
<p>Another advanced scripting technique is the use of context sensitive traversal: 
  The traversal state is extended with a custom element, SoContextElement*, containing 
  a map datastructure that allows to store string-typed key-value pairs. Nodes 
  in the scenegraph can write to or read from the context during traversal, and 
  behave differently depending on the values stored in the context element.</p>
<p>The nodes provided by Studierstube to be used to manipulate and evaluate the 
  traversal context are:</p>
<table width="100%" border="0">
  <tr> 
    <th>Name</th>
    <th>Description</th>
    <th>Fields</th>
  </tr>
  <tr> 
    <td class="nametable"><a href="../stb/classSoContext.html">SoContext</a>*</td>
    <td>modifies the SoContextElement in the state of the current action</td>
    <td class="fildstable">SoSFEnum mode<br>
      SoMFName index<br>
      SoMFString value</td>
  </tr>
  <tr> 
    <td class="nametable"><a href="../stb/classSoContextReport.html">SoContextReport</a>*</td>
    <td>reports values from the SoContextElement in the state of the current action</td>
    <td class="fildstable">SoMFName index<br>
      SoMFString value<br>
      SoMFString defaultValue</td>
  </tr>
  <tr> 
    <td class="nametable"><a href="../stb/classSoContextSwitch.html">SoContextSwitch</a>*</td>
    <td>switch that traverses differently based on the context element</td>
    <td class="fildstable">SoSFName index<br>
      SoSFInt32 defaultChild</td>
  </tr>
  <tr> 
    <td class="nametable"><a href="../stb/classSoContextMultiSwitch.html">SoContextMultiSwitch</a>*</td>
    <td>allows to define subsets of its children and to use the SoContextElement 
      to select during traversal which sets of children will be traversed</td>
    <td class="fildstable">SoSFBool ordered<br>
      SoSFName index<br>
      SoMFInt32 numChildren<br>
      SoMFInt32 defaultChildren</td>
  </tr>
  <tr> 
    <td class="nametable"><a href="../stb/classSoContextSeparator.html">SoContextSeparator</a>*</td>
    <td>Separator that stops notification that occur during traversal</td>
    <td class="fildstable">SoSFBool blockNotify</td>
  </tr>
</table>
<p>Context-sensitive traversal can be used to parameterize scenegraphs. While 
  it is possible to reference a scenegraph multiple times with the DEF / USE mechanism, 
  the scenegraph will be the same with each traversal. Using context-sensitive 
  traversal, the context can be changed before each reference, allowing the developer 
  to set fields in the scenegraph depending on the context entries. For example, 
  we could extend the simple coordinate system presented earlier to add labels 
  to each axis, defined by the context:</p>
<pre class="source">SoContext {                            # initialize context with first name<br>    index &quot;axis-name&quot;<br>    value &quot;Y&quot;<br>}    <br>DEF AXIS Separator {<br>    Transform {<br>        translation 0 0.15 0<br>    }<br>    Cylinder {<br>        radius 0.003<br>        height 0.3<br>    }<br># ... omitting geometry definitions<br>    DEF axisname SoContextReport {     # this will report the name to its &quot;value&quot; field<br>        index &quot;axis-name&quot;<br>    }<br>    Text3 { <br>        string = USE axisname.value    # use the value field to create the label<br>    }<br>}

Material { diffuseColor 1 0 0 }        # change color<br>Rotation { rotation 0 0 1 -1.57 }      # change orientation<br>SoContext {                            # change label<br>  index &quot;axis-name&quot;<br>  value &quot;X&quot;<br>} <br>USE AXIS                               # render 2nd axis

Material { diffuseColor 0 0 1 }        # change color<br>Rotation { rotation 1 0 0 1.57 }       # change orientation<br>SoContext {                            # change label<br>  index &quot;axis-name&quot;<br>  value &quot;Z&quot;<br>} <br>USE AXIS                               # render 3rd axis</pre>
<p>Note that inventor converts every datatype to and from strings. It is therefore 
  possible to set other field types also by connecting them to the string values 
  in the context.</p>
<h4>Python scripting node</h4>
<p>A powerful way to include complex behavior into your scene graph is
to embed an <code>SoPyScript</code> node into your scene graph and define it's
behavior by writing Python scripts. The following example shows how to
to that:</p>
<pre class="source">DEF Concat SoPyScript {
    fields [ SoSFString a, SoSFString b, SoSFString out ]  # defines the fields present in the script node<br>    a "Time "<br>    b = SoTimeCounter { max 10 }.output    <br>    script "<br># write any initialisation directly in the script<br>print 'This script concatenates the inputs a and b and outputs everything on out\n'<br><br># handle_a is called, if a changed<br>def handle_a():<br>    out.setValue( a.getValue().getString() + b.getValue().getString())<br><br># handle_b is called, if a changed<br>def handle_b():<br>    out.setValue( a.getValue().getString() + b.getValue().getString())    <br>"    <br>}<br><br>Translation { translation 0.1 0.1 0 }<br>Text2 {<br>    string = USE Concat.out<br>}<br></pre>

<p class="">The script node has only two fixed fields. The other fields
are defined directly in the file format. The first line always has to
start with <code>fields</code> and then contain a description of the additional
fields as a list of typename and fieldname. The list is enclosed using
<code>[]</code> and can also span several lines.</p>
<p class="">After the definition of the field names, you can use the
fields like any other Open Inventor fields. They can take default
values or can be connected to and from. </p>
<p class="">The Python script itself is put into the field <code>script</code>. It
can span several lines and needs to be formatted following the Python
indentation rules. Therefore it always has to start in the first
column, regardless of the indentation of your Inventor nodes. Within
the script you can use any Python code. Code that does not define
objects will be executed after the script node is loaded or when the
contents of the script field have changed.</p>
<p class="">Within the script code the fields are available in
variables with the same name as the field. The whole Open Inventor API
is supported via the Pivy interface. See the Pivy website for details
on how to use it. Basically all C++ API calls are available directly
and the operators are overloaded as well. There are no shortcuts
implemented, therefore for example you have to use <code>getString()</code> to get a
<code>char *</code> and consequently a Python string from an SbString object.</p>
<p class="">A couple a special functions can be defined within the
script node to link the fields to functions. If a function with the
name <code>handle_fieldname</code> is defined, it is called whenever the field of
the given name changes. In our example the function <code>handle_b</code> is called
whenever the field b receives a new value from the SoTimeCounter engine.</p>
<p class="">Another possibility is to override the different methods
called from action traversals. If a function with the same name as a
virtual action method of the node is found, it is called whenever the
corresponding action traverses the script node. For example the
function <code>GLRender(action)</code> is called whenever the node is rendered.</p>
<p class="navbar">&lt;<a href="content2.html">prev</a>] - [<a href="index.html">up</a>] 
  - [<a href="extending.html">next</a>&gt;</p>
</body>
</html>
