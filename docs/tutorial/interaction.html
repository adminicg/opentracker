<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>Tracking and Interaction</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link href="tutorial.css" rel="stylesheet" type="text/css">
</head>

<body>
<h1>Studierstube scripting mentor</h1>
<h3>Tracking &amp; Interaction</h3>
<p class="navbar">&lt;<a href="behaviour1.html">prev</a>] - [<a href="index.html">up</a>] 
  - [<a href="content2.html">next</a>&gt;</p>
<p>One fundamental building block for realizing applications is still missing: 
  Interaction. For augmented reality applications, user interaction happens primarily 
  through spatially tracked devices, and buttons mounted on these devices. In 
  Studierstube, these devices are connected through the <a href="http://www.studierstube.org/OpenTracker">OpenTracker</a> 
  tracking middleware, which supports a wide range of classical and non-standard 
  interaction devices. Each device is exposed to Studierstube as a so called <em>station</em>, 
  an entity that carries information about position and orientation as well as 
  the state of up to eight buttons. Each station has a number that uniquely identifies 
  it.</p>
<h4>Processing tracking data</h4>
<p>There are generally two ways to process station information. Applications can 
  get the data directly by using a <a href="../stb/classSoTrakEngine.html"><code>SoTrakEngine</code></a>*, 
  that exposes the data through its outputs. Using a SoTrakEngine is straightforward:</p>
<pre class="source">#Inventor V2.0 ascii
 
Transform {
    translation 0 0 0 = DEF POINTER SoTrakEngine {  # this engine delivers tracking data
         station 0                                  # of station 0
    }.translation
 
    rotation 1 0 0 0 = USE POINTER.rotation
}
Switch {
    whichChild 0 = USE POINTER.button0              # will toggle color depending on button state
    Material { diffuseColor 1 0 0 }
    Material { diffuseColor 0 1 0 } 
}
Sphere { radius 0.02 }</pre>
<p>The problem with this approach is that stations carry information about their 
  absolute position in space, while the position of a given part of the scenegraph 
  is defined by the traversal path to that node (and all the transformation nodes 
  on the way). If we would add another transformation at the beginning of the 
  above example, the position delivered by the station would still be the same, 
  but the geometry would appear at a different location and would not be registered 
  with the tracking device any more.</p>
<p>While simple applications can be organized in a way that avoids these kinds 
  of problems, for advanced applications another mechanism should be used: The 
  tracking subsystem generates <em>events</em>, which traverse the scene graph 
  in an action (like rendering). If the event finds a node that is interested 
  in it, at this point it has accumulated also the overall transformation along 
  the traversal path. With this mechanism, not only tracked geometry, but also 
  <em>widgets</em> like buttons or sliders can be implemented to be used with 
  tracked devices.</p>
<p>A fundamental node that makes use of this mechanism is the <a href="../stb/classSoStationKit.html">SoStationKit</a>*. 
  It can be used to conveniently track content in your application, regardless 
  of its position in the transformation hierarchy:</p>
<pre class="source">#Inventor V2.0 ascii
 
SoStationKit {
    station 0
    content Group { # this is a part
        Switch { # will toggle color depending on button state
            whichChild 0 = SoTrakEngine { station 0 }.button0
            Material { diffuseColor 1 0 0 }
            Material { diffuseColor 0 1 0 } 
        }
        Sphere { radius 0.02 }
    }
} 
</pre>
Note that we still had to use a SoTrakEngine for getting the button information, 
since it is not exposed by the SoStationKit. One drawback of using the event traversal 
mechanism is that events can be consumed by event-aware nodes, which makes them 
unavailable for other nodes further down the traversal path. It is therefore possible 
that a node does not receive an event it is waiting for because the event has 
been consumed by a node which has been traversed earlier. 
<h4>Keyboard Input</h4>
<p>Although the keyboard is not a suitable input device for most AR applications, 
  it can be useful for debugging, in desktop setups or as a hardware interface 
  to connect other buttons insted of key. For processing keyboard events, Studierstube 
  provides the <a href="../stb/classSoKeyToggle.html"><code>SoKeyToggle</code></a>* 
  node:</p>
<pre class="source">SoKeyToggle {
 
  # field name # default value # type        # description
 
    key          &quot;&quot;            # SoSFString  # defines the key to react on. Only the first character is used
    pressed      &quot;&quot;            # SoSFString  # contains list of all currently pressed keys
    isPressed    FALSE         # SoSFBool    # indicates whether the selected key is currently pressed
    toggled      FALSE         # SoSFBool    # is flipped with each key press
    shift        FALSE         # SoSFBool    # TRUE if shift is pressed, FALSE otherwise
    alt          FALSE         # SoSFBool    # TRUE if alt is pressed, FALSE otherwise
    ctrl         FALSE         # SoSFBool    # TRUE if ctrl is pressed, FALSE otherwise
}</pre>
<h4>Ray-pointing</h4>
<p>While &quot;normal&quot; pointing can be realized by using StationKits, sometimes 
  it is desireable to point at objects at a distance using a laser-pointer like 
  device, called a raypicker. This behaviour is provided by the <code><a href="../stb/classSoRayPicker.html">SoRayPicker</a></code>* 
  node:</p>
<pre class="source">SoRayPicker {<br>  # field name   default value # type        | description
  # general parameters<br>    active       FALSE         # SoSFBool  <br>    stations     -1            # SoSFInt32 <br>    pickGraph    NULL          # SoSFNode  <br> <br>  # pick parameters<br>    radius       1.0           # SoSFFloat <br>    nearDistance -1.0          # SoSFFloat <br>    farDistance  -1.0          # SoSFFloat <br>    refPoint     0 0 0         # SoSFVec3f <br>    userId       -1            # SoSFInt32 <br> <br>  # modes<br>    mode         RAY           # SoSFEnum   | RAY | STICK <br>    coordinates  NORMALIZED    # SoSFEnum   | NORMALIZED | ABSOLUTE <br>    input        POSE          # SoSFEnum   | POSE | POSITION | SCREEN 

    content      Cylinder {}   # (SoSFNode) | (part) geometry to visualize the ray<br><br>  # outputs<br>    pickedPath   NULL          # SoSFPath <br>    pickedPoint  0 0 0         # SoSFVec3f <br>    pickedOrientation 0 0 1 0  # SoSFRotation <br>    pickedNormal 0 0 0         # SoSFVec3f <br>    pickedTextureCoord 0 0 0 0 # SoSFVec4f <br>    button       0             # SoSFInt32 <br>    isPicking    FALSE         # SoSFBool <br>}</pre>
<h4>Widgets</h4>
<p>Widgets are parts of the scene that react to user interaction without needing 
  further low-level event scripting. They can be used for arranging complex user 
  interfaces. Note that widgets react to <em>any</em> stations that intersect 
  their geometry!</p>
<table width="100%" border="0">
  <tr> 
    <th>Name</th>
    <th>Description</th>
    <th>Fields</th>
  </tr>
  <tr> 
    <td class="nametable">Common Attributes </td>
    <td><p>All widgets share a common set of attributes. The size of the widget 
        can be specified using the width, height and depth attributes. All widgets 
        can be enabled or disabled.</p>
      <p>The hysteresis box is the volume that reacts to events - usually a bit 
        larger than the widget itself, and not affected by a resizing of the widget 
        due to user interaction.</p>
      <p>All widgets can provide labels and toltips, which are defined in seperate 
        helper classes and attached to the widget.</p></td>
    <td class="fildstable"> <p>SoSFFloat width<br>
        SoSFFloat height<br>
        SoSFFloat depth</p>
      <p> SoSFFloat hysteresisBoxScale<br>
        SoSFFloat hysteresisBoxScaleHeight<br>
        SoSFBool enable<br>
        SoSFEnum labelPlacing</p>
      <p>(SoLabelKit) label<br>
        (SoTooltipKit) tooltip<br>
        (SoTooltipKit) tooltipDisabled</p></td>
  </tr>
  <tr> 
    <td class="nametable"><a href="../stb/classSoPushButton.html">SoPushButton</a>* 
      (Kit) </td>
    <td>Implements a push button that can be used to trigger behaviour. Triggers 
      can also be sent repeatedly, as long as the button is pressed, at configurable 
      intervals.</td>
    <td class="fildstable">
<p> SoSFBool highlighted<br>
        SoSFBool on<br>
        SoSFTrigger triggerOut<br>
        SoSFTrigger triggerIn<br>
        SoSFBool triggerOnUp<br>
        SoSFBool repeatTrigger<br>
        SoSFTime repeatTriggerStartInterval<br>
        SoSFTime repeatTriggerInterval</p>
      <p>(SoNode) onGeometry<br>
        (SoNode) offGeometry<br>
        (SoNode) highlightedOnGeometry<br>
        (SoNode) highlightedOffGeometry<br>
        (SoNode) externalOnGeometry<br>
        (SoNode) disabledOnGeometry<br>
        (SoNode) disabledOffGeometry</p>
      </td>
  </tr>
  <tr> 
    <td class="nametable"><a href="../stb/classSoToggleButton.html">SoToggleButton</a>* 
      (Kit) </td>
    <td>Implements a button that can be toggled between on and off states.</td>
    <td class="fildstable"><p>SoSFBool highlighted<br>
        SoSFBool on<br>
        SoSFBool onIn</p>
      <p>(SoNode) onGeometry<br>
        (SoNode) offGeometry<br>
        (SoNode) highlightedOnGeometry<br>
        (SoNode) highlightedOffGeometry<br>
        (SoNode) externalOnGeometry<br>
        (SoNode) disabledOnGeometry<br>
        (SoNode) disabledOffGeometry</p>
      </td>
  </tr>
  <tr> 
    <td class="nametable"><a href="../stb/classSoSimpleSlider.html">SoSimpleSlider</a>* 
      (Kit) </td>
    <td> Implements a typical 2D slider widget, to control float values. Its alpha 
      value can be routed to an interpolator class to be able to control other 
      value types.</td>
    <td class="fildstable"><p>SoSFBool highlighted<br>
        SoSFBool dragging</p>
      <p>SoSFFloat value<br>
        SoSFFloat valueIn<br>
        SoSFFloat minValue<br>
        SoSFFloat maxValue<br>
        SoSFFloat alpha<br>
        SoSFFloat alphaIn</p>
      </td>
  </tr>
  <tr> 
    <td class="nametable"> <a href="../stb/classSoIncrementalSlider.html">SoIncrementalSlider</a>* 
      (Kit) </td>
    <td>Implements a typical 2D slider widget, with buttons to increment and decrement 
      the value</td>
    <td class="fildstable"><p>SoSFFloat minValue<br>
        SoSFFloat maxValue<br>
        SoSFFloat value<br>
        SoSFFloat valueIn<br>
        SoSFFloat alpha<br>
        SoSFFloat increment<br>
        SoSFFloat buttonSpace<br>
        SoSFTime interval<br>
        SoSFTrigger startDragging<br>
        SoSFTrigger finishedDragging</p>
      </td>
  </tr>
  <tr> 
    <td class="nametable"><a href="../stb/classSoTextListBox.html">SoTextListBox</a>* 
      (Kit) </td>
    <td>Provides a simple list box interface with a number of buttons showing 
      different items and a SoIncrementalSlider allowing to navigate through the 
      possible items.</td>
    <td class="fildstable"><p>SoSFBool multipleSelections<br>
        SoSFBool noneSelectionAllowed<br>
        SoSFInt32 numOfRows<br>
        SoSFInt32 numOfCols<br>
        SoSFInt32 displayIndex<br>
        SoSFInt32 displayIndexIn<br>
        SoMFBool states<br>
        SoMFInt32 selectedIndices<br>
        SoMFInt32 selectedIndicesIn</p>
      <p>SoMFString values<br>
        SoMFString selectedValues</p></td>
  </tr>
  <tr bgcolor="#CCCCCC"> 
    <td colspan="3" class="innerheader">Support Classes</td>
  </tr>
  <tr> 
    <td class="nametable"><a href="../stb/classSoLabelKit.html">SoLabelKit</a>* 
      (Kit) </td>
    <td>Represents a label (text) as part of a widget</td>
    <td class="fildstable">SoMFString text<br>
      SoMFVec3f translations<br>
      SoSFBool resizeToWidget<br>
      SoSFBool uniformScale</td>
  </tr>
  <tr> 
    <td class="nametable"><a href="../stb/classSoTooltipKit.html">SoTooltipKit</a>* 
      (Kit) </td>
    <td>Represents a tooltip plane with text</td>
    <td class="fildstable">SoMFString text<br>
      SoSFBool show<br>
      SoSFFloat timeOut<br>
      SoSFBool adaptSize<br>
      SoSFTrigger startShow<br>
      SoSFTrigger stopShow</td>
  </tr>
</table>
<p>Widgets can be placed in the scene like any other geometry, and will react 
  to events generated by stations.</p>
<p>For details about more advanced widget scripting, see <a href="../stb/userInterfaces.html">../stb/userInterfaces.html</a></p>
<h3>Dragging</h3>
<p>Things can be moved around in the scene by dragging them with a tracked device. 
  the <a href="../stb/classSoDragKit.html"><code>SoDragKit</code></a>* supports 
  this kind of behavior:</p>
<pre class="source">SoRayPicker {<br>  # field name   default value # type        | description
    translation  0 0 0         # SoSFVec3f<br>    rotation     1 0 0 0       # SoSFRotation

  # these flags control the degrees of freedom that are allowed<br>    translationOn TRUE         # SoSFBool 	<br>    xTranslationOn TRUE        # SoSFBool 	<br>    yTranslationOn TRUE        # SoSFBool 	<br>    zTranslationOn TRUE        # SoSFBool 	<br>
    rotationOn    TRUE         # SoSFBool 	<br>    xRotationOn   TRUE         # SoSFBool 	<br>    yRotationOn   TRUE         # SoSFBool 	<br>    zRotationOn   TRUE         # SoSFBool 	
<br>  # remaining fields<br>    draggingStation            # SoSFInt32 	<br>    dragButton                 # SoSFInt32 	<br>    dragging                   # SoSFBool 	<br>    validFlag                  # SoSFBool

  # parts
    content       NULL         # SoNode
    highlightedContent NULL    # SoNode
}</pre>
<p></p>
<h3>The Personal Interaction Panel (PIP)</h3>
<p>One of the problems with widgets is that they are much harder to operate by 
  users if they are placed in open space. The PIP gives Studierstube users a tangible 
  surface, on which widgets can be arranged to control applications. Usually, 
  the PIP is a tracked board that is held by the user, and the widgets are superimposed 
  on that board. Other implementations use a trackpad to generate a virtual &quot;mouse&quot;-pointer 
  for the PIP, or use it as a heads-up display (HUD) superimposed over the camera 
  image.</p>
<p><img src="images/pip.jpg" width="600" height="243"></p>
<p>Fig.: Two different PIP implementations</p>
<p>Widgets for the PIP are arranged in so-called PIP-sheets. An application can 
  provide multiple PIP-sheets, which should group GUI functionality into smaller 
  units. Usually, these PIP-sheets are loaded form one or multiple external files, 
  which are referenced in the main application file. For operating the widgets 
  on a PIP, a pen is used, that generates the tracking events which are processed 
  by the widgets.</p>
<p>In the simple example setup, the PIP geometry will be loaded from the file 
  content/pip.iv, and the PIPs content will be loaded from the file pipSheet1.iv.</p>
<p>Details about configuring PIPs &amp; pens are given in <a href="setup.html">section 
  9, Studierstube Setup</a>.</p>
<p><a href="examples/example3.iv">example3.iv</a> uses SoDragKits and a button 
  on the PIP for a simple NURBS editor. The PIP-sheet for this example is <a href="examples/example3_pipsheet.iv">example3_pipsheet.iv</a>.</p>
<p class="navbar">&lt;<a href="behaviour1.html">prev</a>] - [<a href="index.html">up</a>] 
  - [<a href="content2.html">next</a>&gt;</p>
</body>
</html>
