<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <title>Extending Open Inventor</title>
  <meta http-equiv="Content-Type"
 content="text/html; charset=iso-8859-1">
  <link href="tutorial.css" rel="stylesheet" type="text/css">
</head>
<body>
<h1>Studierstube scripting mentor</h1>
<h3>Extending Open Inventor</h3>
<p class="navbar">&lt;<a href="behaviour2.html">prev</a>] - [<a
 href="index.html">up</a>] - [<a href="setup.html">next</a>&gt;</p>
<p>Complex functionality can not
always be achieved by concatenating engines and assembling nodes in a
scene graph. Therefore Studierstube and the underlying Open Inventor
library allow for extensions in a variety of ways. Typically such
extensions take the form of new C++ classes which are derived from
classes defined in the framework. Thus such extensions must be
developed in C++.</p>
<p>Studierstube is a set of
extensions classes to Open Inventor. To add new functionality to it can
be done by writing new Open Inventor extensions. The basic API to do so
is covered by two very good books on Open Inventor, <em>The Inventor
Mentor</em> and <em>The Inventor Toolmaker.</em> Details on writing
new extensions can be found there, we give only a short introduction
into the most common types here. </p>
<p>To
get in-depth information on what nodes, nodekits and engines are read
the Inventor Mentor chapters 2 (omit pp 70-71), 3, 9, 12, 13, 14. To
know more about extending Open Inventor read the Inventor Toolmaker
chapters 1, 2, 6, 7.</p>
<h4>Nodes</h4>
<p>The basic blocks of Open
Inventor are nodes which in turn are assembled into scene graphs.
Therefore, writing new nodes is a common way to add new behavior or
rendering to an Open Inventor or Studierstube application. </p>
<p>To define a new node, you need
to be clear about its functionality and the parameters required to
control the functions. Nodes are parametrized using fields, therefore
you should map the parameters to a set of fields of the node. Moreover,
a node is traversed by actions as part of a scene graph. Any special
behavior of the node is usually triggered through these actions. For
example the rendering code of a node is triggered by a callback from
the SoGLRenderAction. Interaction with user input is triggered by an
SoHandleEventAction or SoHandle3DEventAction. For each action a node
defines a virtual method which is called by that action. To specify a
uniform behavior across all nodes use the virtual method doAction.</p>
<p>To define a node a set of macros have to be used. A template for a
new node looks as follows:</p>
<pre class="source">#include &lt;Inventor/nodes/SoSubNode.h&gt;<br>#include &lt;Inventor/fields/SoSFBool.h&gt;<br><br>class ButtonPress : public SoNode <br>{<br>    SO_NODE_HEADER(ButtonPress)<br>public:<br>    ButtonPress(void);<br>    static void initClass(void);<br><br>    SoSFBool left;<br>    SoSFBool middle;<br>    SoSFBool right;<br><br>protected:<br>    virtual ~ButtonPress();<br><br>    virtual void handleEvent( SoHandleEventAction *action);<br>};</pre>
<p>The node ButtonPress will
react to input events and report if the left, middle or right mouse
button is pressed. Some notes on the header file:</p>
<ul>
  <li>Include the header SoSubNode to have the necessary macros to
create a new node</li>
  <li>The static method initClass needs to be declared and defined as
shown later to register the new class with the system.</li>
  <li>destructors
should be protected and virtual. Nodes should never be destructed from
application code, as the reference counting system takes care of them.</li>
  <li>The handleEvent method will be called by the action transporting
the input event.</li>
</ul>
<p>Lets have a look at the source code to define the methods of our new
node:</p>
<pre class="source">#include "ButtonPress.h"<br><br><br>SO_NODE_SOURCE(ButtonPress);<br><br><br>void ButtonPress::initClass(void)<br>{<br>    SO_NODE_INIT_CLASS(ButtonPress, SoNode, "Node");<br>}<br><br>ButtonPress::ButtonPress(void)<br>{<br>    SO_NODE_CONSTRUCTOR(ButtonPress);<br>    SO_NODE_ADD_FIELD(left, (FALSE));<br>    SO_NODE_ADD_FIELD(middle, (FALSE));<br>    SO_NODE_ADD_FIELD(right, (FALSE));<br>}<br><br>ButtonPress::~ButtonPress()<br>{}<br><br>void ButtonPress::handleEvent( SoHandleEventAction * action )<br>{<br>    SoEvent * event = action-&gt;getEvent();<br>    if( event-&gt;isOfType( SoMouseButtonEvent::getClassTypeId())<br>    {<br>        SoMouseButtonEvent * mbevent = (SoMouseButtonEvent *) event;<br>        switch( mbevent-&gt;getButton())<br>        {<br>        case SoMouseButtonEvent::BUTTON1:<br>            left-&gt;setValue(mbevent-&gt;getState());<br>        break;<br>        case SoMouseButtonEvent::BUTTON2:<br>				middle-&gt;setValue(mbevent-&gt;getState());<br>        break;<br>        case SoMouseButtonEvent::BUTTON3:<br>				right-&gt;setValue(mbevent-&gt;getState());<br>        break;<br>        }<br>    }<br>}</pre>
<p>Note the following things in the source file:</p>
<ul>
  <li>The macro SO_NODE_SOURCE needs to be declared here.</li>
  <li>The
implementation of initClass is basically SO_NODE_INIT_CLASS. The third
parameter of the macro is the classname as used in the file format.
This is the classname without the 'So' prefix for all nodes of Open
Inventor and just the class names for all other classes (such as
Studierstube classes). </li>
  <li>Within
the constructor all fields have to be defined using SO_NODE_ADD_FIELD.
The second parameter is the default value and has to be given with the
parenthesis (e.g. (FALSE), not FALSE).</li>
</ul>
<h5>Field sensors</h5>
<p>Some more complex behavior will
require to act on fields of the node. In such a case, use a
SoFieldSensor object to observe the field and be called back whenever
it changes. A SoFieldSensor takes a function or a static method and
will call it whenever a field value has changed. It can be attached to
any field, but only one field at a time. Because it is not part of the
reference counting scheme of Open Inventor, you have to take care of it
yourself. The typical code looks like that:</p>
<pre class="source">...<br>#include &lt;Inventor/sensors/SoFieldSensor.h&gt;<br><br><br>class ButtonPress: public SoNode<br>{<br>...<br><br>protected:<br>    static void fieldChanged( void * data, SoSensor * sensor);<br>    SoFieldSensor fieldSensor;<br><br>}</pre>
<p>We defined the SoFieldSensor as a simple member, this ensures that
it is available in the constructor and will be deleted, when the node
is deleted. This is exactly what we want, so we do not need any further
bookkeeping. The static method will be called by the SoFieldSensor and
will implement any special behavior.<br>
</p>
<pre class="source">ButtonPress::PuttonPress()<br>{<br>    ...<br>    fieldSensor.setData( this );                              // set data pointer passed to callback<br>    fieldSensor.setFunction( ButtonPress::fieldChanged );     // set callback function<br>    fieldSensor.attach( &amp;left );                              // attach to field to observe (requires a pointer)<br>}<br><br><br>void ButtonPress::fieldChanged( void * data, SoSensor * sensor )<br>{<br>    assert( data != NULL );<br>    assert( ((SoNode *)data)-&gt;isOfType( ButtonPress::getClassTypeId()));<br>    ButtonPress * self = (ButtonPress *) data;<br><br>    printf("Button was pressed\n");<br>}</pre>
<p>To setup the SoFieldSensor we have to add a few lines to the
constructor. We need to set the function to be called, then any
additional data we want to pass into the function and finally tell the
SoFieldSensor object which field to observe by attaching it to the
field. We pass in the this pointer as additional data to be able to
access the node from within the static callback function.</p>
<p>In the callback function we simply cast the data pointer to a class
pointer and can now implement any advanced functionality. It is always
a good idea to use a couple of assert statements to make sure that the
data passed in is valid to catch possible bugs in your code.</p>
<h4>Engines</h4>
<p>Engines can be created in a
similar way as nodes. They are somewhat simpler because they do not
deal with actions at all. They also provide a standard way of observing
field values and recalculating the outputs.</p>
<p>An engine has fields for input
values and defines outputs to write the result of its specific
calculation. Open Inventor optimizes the evaluation of such engines so
that it is only triggered if the value of an output is actually
required. To support this optimization the implementation of an action
must follow a certain pattern.</p>
<p>Computation of the output state
has to be implemented in the abstract virtual method evaluate(). Open
Inventor calls it automatically, if it requires an update of the engine
outputs. The implementation typically reads out the input fields of the
engine, computes the results and writes them into the outputs.</p>
<p>Engine outputs do not hold any
values, but only references to connected fields. A set of macros are
used to directly write the results into the connected fields. These
make the engine outputs appear as simple objects.</p>
<p>The following example engine
takes the values of the string input fields and returns the
concatenation of the individual string values.</p>
<pre class="source">#include &lt;Inventor/engines/SoSubEngine.h&gt;<br>#include &lt;Inventor/fields/SoMFString.h&gt;<br><br>class Concat: public SoEngine<br>{<br>    SO_ENGINE_HEADER(Concat);<br><br>public:<br>    Concat(void);<br>    static void initClass(void);<br><br>    SoMFString a;<br>    SoMFString b;<br><br>    SoEngineOutput aCb;<br>    SoEngineOutput bCa;<br><br>protected:<br>    virtual ~Concat();<br>    virtual void evaluate(void);<br>}</pre>
<p>The header looks simple enough.
Again there are similar macros to define an engine. The source code
implements the evaluate function to calculate the two concatenations of
the strings a and b. Note, that the two engine outputs are not typed.
This will be defined in the implementation in the source file:</p>
<pre class="source">#include "Concat.h"<br><br>SO_ENGINE_SOURCE(Concat);<br><br>void Concat::initClass(void)<br>{<br>    SO_ENGINE_INIT_CLASS(Concat, SoEngine, "Engine");<br>}<br><br>Concat::Concat(void)<br>{<br>    SO_ENGINE_CONSTRUCTOR(Concat);<br>    SO_ENGINE_ADD_INPUT(a, (""));<br>    SO_ENGINE_ADD_INPUT(b, (""));<br>    SO_ENGINE_ADD_OUTPUT(aCb, SoMFString);<br>    SO_ENGINE_ADD_OUTPUT(bCa, SoMFString);<br>}<br><br>void Concat::evaluate(void)<br>{<br>    unsigned int max = (a.getNum() &gt; b.getNum()) ? a.getNum() : b.getNum();<br><br>    SO_ENGINE_OUTPUT(aCb, SoMFString, setNum(max));<br>    SO_ENGINE_OUTPUT(bCa, SoMFString, setNum(max));<br><br>	   for( unsigned int i = 0; i &lt; max; i ++ )<br>    {<br>        SbString va = (a.getNum() &gt; i) ? a[i] : "";<br>        SbString vb = (b.getNum() &gt; i) ? b[i] : "";<br>        SbString t1 = va + vb;<br>        SbString t2 = vb + va;<br>        SO_ENGINE_OUTPUT(aCb, SoMFString, set1Value(i,t1));<br>        SO_ENGINE_OUTPUT(bCa, SoMFString, set1Value(i,t2));<br>    }<br>}</pre>
<p>Again,
macros similar to the ones used in the node source are required to
create an engine. Also the method initClass uses the macro
SO_ENGINE_INIT_CLASS with the same arguments as the
corresponding macro for nodes. Within the constructor two macros are
used to define the inputs and outputs of the engine. The
SO_ENGINE_ADD_INPUT macro corresponds to the SO_NODE_ADD_FIELD macro
and takes the same parameters. The SO_ENGINE_ADD_OUTPUT macro, however,
only takes the name and the type of the output, but no default value.</p>
<p>The method evaluate implements
the functionality of the engine. It is called whenever the outputs of
the engine need to be re-evaluated. This happens only, if the inputs
have changed and a field connected to an output is used. For example,
if the engine output is connected to the string field of an SoText2
node, the field will be read to render the correct text. Then the
engine will be evaluated to update it's output values.</p>
<p>Output values are set with a
special macro SO_ENGINE_OUTPUT. It takes three parameters: the name of
the output, the type of the output and the method to call on the
connected fields. The macro will actually expand to code that calls all
connected fields, therefore it requires the type of the field and the
method invocation with all parameters. The method will be called for
each field that is connected, therefore you should not use any
expressions in the parameters, as they will be evaluated as well for
each field. </p>
<p>In our example we use the macro
twice. First we set the number of values in the connected fields to the
number of values we are going to compute using setNum(). This resizes
the output fields to hold the right number of values. Then we set each
value in the connected fields using the call set1Value() with the
necessary parameters.</p>
<h5>MFFields vs. SFFields</h5>
<p>Why did we define our engine's
input and outputs to use multiple value fields ? Open Inventor provides
default conversions between single and multiple value fields.
Therefore, if we implement an engine using multiple value fields, we
get one for single value fields for free.&nbsp; Note, that we also
create as many results as the maximum number of values in any input
field and simply reuse the last values for inputs that have less
values.Most buildin Open Inventor engines work that way and it is
therefore the most appropriate way to deal with such situations. </p>
<h4>Nodekits</h4>
<p>Nodekits are a special
variation of nodes. They are part of the scene graph and also
encapsulate a small sub scene graph itself. Thus they can be used to
build reusable scene graph components and to create fixed connections
and dependencies between the nodes of the sub scene graph. Nodekits add
the concept of a part to the concept of nodes. A part is a node within
the sub scene graph controlled by the nodekit. The parts are arranged
in a fixed graph when the nodekit is initialized. The resulting sub
scene graph is traversed by all actions in the standard way.</p>
<h4>How to package extensions ?</h4>
<p>All your new node and engine
extensions need to be available somehow to your application. There are
different ways to do that. You can link the extensions code to your
application or create a shared library containing the extension. </p>
<p>If you already have an
application that links to Open Inventor, you can simply add the
extensions to the application. To register the new nodes, nodekits or
engines with Open Inventor, you need to call the static method
initClass for each extension. The macro in the definition of initClass
will then register the new type with the runtime type system of Open
Inventor which performs such magic tasks as reading and writing files
containing your node. The registration needs to happen before the first
instance of an extension is created !</p>
<p>The second case is useful, if
you just want to create new extensions to use in pure Open Inventor
scripting applications that only consist of scene-graph files. To be
able to load and register your extension with Open Inventor, you have
to use a special Studierstube node called SoClassLoader. It is
configured with a shared library name and a class name. When it is read
in or created it will try to load the shared library and find the
initClass method corresponding to the given class name. If found, it
calls it and thus registers the extension with Open Inventor. From then
on, the extension node can appear immediatly in the same scene-graph
file.</p>
<table border="0" width="100%">
  <tbody>
    <tr>
      <th>Name</th>
      <th>Description</th>
      <th>Fields</th>
    </tr>
    <tr>
      <td class="nametable"><a
 href="http://www.studierstube.org/doc/stb/classSoClassLoader.html">SoClassLoader*</a></td>
      <td>loads new extension nodes, nodekits or engines from a shared
library<br>
      </td>
      <td class="fildstable">
      <p>SoSFString fileName<br>
SoSFString className</p>
      </td>
    </tr>
  </tbody>
</table>
<p>The fileName field should only
contain the name part of the shared library but not the extension to be
deployable cross-platform. Also one should only use '/' to delimit
directories to be cross-platform again. On Windows you can also leave
out the 'd' suffix for Debug builds because the SoClassLoader node will
first try to find a shared library with the 'd' suffix appended, if it
is running in a Debug build. This behavior allows you to use the same
scene-graph files for both Release and Debug builds. The following
example shows how to load the node SoPyScript and is taken from <a
 href="examples/example4.iv">example4.iv</a>:</p>
<pre class="source">SoClassLoader {<br>    fileName "pyscript"<br>    className "SoPyScript"<br>}</pre>
<p class="navbar">&lt;<a href="behaviour2.html">prev</a>] - [<a
 href="index.html">up</a>] - [<a href="setup.html">next</a>&gt;</p>
</body>
</html>
