<?xml version="1.0" encoding="UTF-8"?>
<!-- edited with XMLSPY v5 rel. 2 U (http://www.xmlspy.com) by Architekt (Vienna University of Technology) -->
<!--DTD generated by XMLSPY v5 rel. 2 U (http://www.xmlspy.com)-->
<!ELEMENT action EMPTY>
<!ATTLIST action
	auto CDATA #IMPLIED
>
<!ELEMENT always EMPTY>
<!ATTLIST always
	auto CDATA #IMPLIED
>
<!--The root element of every APRIL file.-->
<!ELEMENT april (setup?, presentation?)>
<!ELEMENT buttonaction EMPTY>
<!ATTLIST buttonaction
	auto CDATA #IMPLIED
	virtual CDATA #IMPLIED
	caption CDATA #IMPLIED
>
<!ELEMENT disabled EMPTY>
<!ATTLIST disabled
	auto CDATA #IMPLIED
>
<!--The base element from which all interaction elements are derived. Allows for exchangeability of interaction elements.-->
<!ELEMENT interaction EMPTY>
<!ATTLIST interaction
	auto CDATA #IMPLIED
>
<!ELEMENT rayaction EMPTY>
<!ATTLIST rayaction
	auto CDATA #IMPLIED
	target IDREF #REQUIRED
>
<!--A state in a hierarchical state machine.-->
<!ELEMENT scene (annotation*, ((scene*, transition*) | (concurrentScene+)))>
<!ATTLIST scene
	name ID #REQUIRED
	initial CDATA #IMPLIED
>
<!ELEMENT sceneaction EMPTY>
<!ATTLIST sceneaction
	auto CDATA #IMPLIED
	target IDREF #REQUIRED
>
<!ELEMENT timeout EMPTY>
<!ATTLIST timeout
	auto CDATA #IMPLIED
	time CDATA #IMPLIED
>
<!--A transition from one state to another, specifying the transition event name.-->
<!ELEMENT transition EMPTY>
<!ATTLIST transition
	event CDATA #REQUIRED
	source CDATA #REQUIRED
	target CDATA #REQUIRED
	guard CDATA #IMPLIED
>
<!--Wrapper element for input and output device configuration. The config section of the APRIL file specified as src is imported (if present), and overlayed with the information of the local config section (this means that local elements with the same id as in the src file, and their child-elements, override the elements specified in the src file). The low-level tracking configuration is done in the OpenTracker file specified with the otsource attribute, or inline in the corresponding interaction elements (see below).-->
<!ELEMENT setup (input?, output?)>
<!--otfile: URI of OpenTracker config file to use as a basis for the tracking configuration. Named OpenTracker nodes referenced in the APRIL file are referenced from this file.-->
<!--workspacepath: Path to the executable(s) of the traget platform.-->
<!ATTLIST setup
	id ID #IMPLIED
	src CDATA #IMPLIED
	otfile CDATA #IMPLIED
	workspacepath CDATA #IMPLIED
>
<!--This is the top-level wrapper element of a APRIL presentation.-->
<!ELEMENT presentation (cast, interactions, behaviors, story)>
<!--id: Unique ID for this presentation. Depending on the implementation of the transformation of APRIL to a specific platform, this will be used for generating file- or folder names for the resulting files.-->
<!--name: The name of the presentation. This can be used by target platforms as a human-readable title for the presentation.-->
<!ATTLIST presentation
	id ID #REQUIRED
	name CDATA #IMPLIED
>
<!ELEMENT annotation ANY>
<!ELEMENT concurrentScene (annotation*, ((scene*, transition*) | (concurrentScene+)))>
<!ATTLIST concurrentScene
	name ID #REQUIRED
	initial CDATA #IMPLIED
>
<!--Wrapper element for high-level input device description.-->
<!ELEMENT input (station+)>
<!--Wrapper element for output device(s) configuration.-->
<!ELEMENT output (screen*, display+)>
<!--This element holds all references to used media resources (models, images, sounds, scripts etc.).-->
<!ELEMENT cast ((stage* | actor* | light* | sound*)+)>
<!ELEMENT interactions (event*)>
<!--The behaviours section binds behaviours of objects to states of the story logic.-->
<!ELEMENT behaviors (behavior*)>
<!--The content of this element specifies the logic (or the "story") of the presentation as a hierarchical state machine. The syntax is derived from XMI, the official UML-to-XML serialization syntax, but simplified for better readability.-->
<!ELEMENT story (annotation*, ((scene*, transition*) | (concurrentScene+)))>
<!ATTLIST story
	name CDATA #IMPLIED
	initial CDATA #IMPLIED
>
<!--Defines a tracked artifact like a marker.-->
<!ELEMENT station ANY>
<!ATTLIST station
	id ID #IMPLIED
	otsource CDATA #IMPLIED
>
<!--Configures a VGA output port.-->
<!ELEMENT screen EMPTY>
<!--resolution: Screen resolution in pixels.-->
<!ATTLIST screen
	resolution CDATA #IMPLIED
>
<!--Defines a display for rendering content on. The containing displaytracking and/or headtracking elements define optional tracking, this elements configures the position of the display window on an output port, its resolution and the default camera pose in the world.-->
<!ELEMENT display (headtracking?, displaytracking?)>
<!--screen: The screen number this display window should be rendered on.-->
<!--screenPosition: position of the top left corner of the display window on the screen in pixels.-->
<!ATTLIST display
	id ID #IMPLIED
	screen CDATA "1"
	screenPosition CDATA "0 0"
	screenSize (fullscreen) "fullscreen"
	stereo CDATA "false"
	worldPosition CDATA "0 0 0"
	worldSize CDATA "0.4 0.3"
	worldOrientation CDATA "0 0 1 0"
	eyeOffsetL CDATA "-0.03 0 0"
	eyeOffsetR CDATA "0.03 0 0"
	viewpointPosition CDATA "0 0 0.5"
	mode (AR | VR | light) "AR"
	debug CDATA #IMPLIED
>
<!--Defines geometry as a proxy for real world objects. In augmented reality applications, this is not displayed, but used for correct rendering of intersections between virtual and real content, for example. In VR and authoring setups, these objects may be rendered as regular scene objects. -->
<!ELEMENT stage (inline?, alt*)>
<!--type: The MIME-type of the content.-->
<!--src: The URI to load the content from.-->
<!ATTLIST stage
	type CDATA #REQUIRED
	src CDATA #IMPLIED
	id ID #REQUIRED
	position CDATA "0 0 0"
	orientation CDATA "0 0 1 0"
	scale CDATA "1 1 1"
	transparency CDATA "0.0"
	visible CDATA "true"
>
<!ELEMENT actor (field*, part*)>
<!ATTLIST actor
	id ID #REQUIRED
	src CDATA #REQUIRED
>
<!ELEMENT light ANY>
<!--A sound to be played in the presentation.-->
<!ELEMENT sound (inline?, alt*)>
<!--type: The MIME-type of the content.-->
<!--src: The URI to load the content from.-->
<!ATTLIST sound
	type CDATA #REQUIRED
	src CDATA #IMPLIED
	id ID #REQUIRED
>
<!ELEMENT event ((interaction*)+)>
<!ATTLIST event
	id ID #REQUIRED
>
<!--A behavior is a set of property changes bound to a state of the tory logic. Whenever the state is entered, the actions defined in the "entry" sub-element are performed. If the story is still in this state after perfomring the entry actions, the "do" actions are performed, and can be interrupted at any time by leaving the state. Upon leving the state, the "exit" actions are guaranteed to perform.-->
<!ELEMENT behavior (entry?, do?, exit?)>
<!ATTLIST behavior
	scene IDREF #REQUIRED
>
<!--Configures the headtracking for the parent display element.-->
<!ELEMENT headtracking ANY>
<!ATTLIST headtracking
	id ID #IMPLIED
	otsource CDATA #IMPLIED
>
<!--Configures tracking of the center of the display.-->
<!ELEMENT displaytracking ANY>
<!ATTLIST displaytracking
	id ID #IMPLIED
	otsource CDATA #IMPLIED
>
<!--You can specify content inline by wrapping it with this tag and putting it as a first child of the actor element. Note that if a src attribute is present on the parent element, the inline content will be treated as if specified within an alt tag, i.e. only used when the content specified by src cannot be retrieved.-->
<!ELEMENT inline ANY>
<!ELEMENT alt (inline?)>
<!--type: The MIME-type of the content.-->
<!--src: The URI to load the content from.-->
<!ATTLIST alt
	type CDATA #REQUIRED
	src CDATA #IMPLIED
	id CDATA #IMPLIED
>
<!ELEMENT field EMPTY>
<!ATTLIST field
	id CDATA #REQUIRED
	value CDATA #REQUIRED
>
<!ELEMENT part ANY>
<!--The "entry" actions are performed when the associated state is entered. Actions defined here are guaranteed to perform, now matter how long the story remains in this state. Actions should therefore only be "set" and "connect", and very short "animate"ions.-->
<!ELEMENT entry ((set*, animate*, connect*, disconnect*, control*)+)>
<!ATTLIST entry
	duration CDATA #IMPLIED
>
<!--Actions in this group are performed as long as the story is in the associated state. Note that actions might not be called at all, if the state is immediately left. This is the only place where looped animations make sense, because they can be cancelled by leaving the state. -->
<!ELEMENT do ((set*, animate*, connect*, disconnect*, control*)+)>
<!--Actions defined here are executed when the associated state is left. They are guaranteed to perform.-->
<!ELEMENT exit ((set*, animate*, connect*, disconnect*, control*)+)>
<!--Sets the given attribute to the given value.-->
<!ELEMENT set EMPTY>
<!ATTLIST set
	attributeName CDATA #REQUIRED
	actor IDREF #REQUIRED
	to CDATA #REQUIRED
	time CDATA "PT0.0S"
>
<!--Animates the given attribute. For further information, see the SMIL animation spec.-->
<!ELEMENT animate EMPTY>
<!ATTLIST animate
	attributeName CDATA #REQUIRED
	actor IDREF #REQUIRED
	begin CDATA "PT0.0S"
	duration CDATA #REQUIRED
	to CDATA #IMPLIED
	by CDATA #IMPLIED
	calcMode CDATA #IMPLIED
>
<!--Connects an attribute of the actor to the attribute of another actor. If persist=true, this connection persists also if the state is left, otherwise it is disconnected again.-->
<!ELEMENT connect EMPTY>
<!ATTLIST connect
	attributeName CDATA #REQUIRED
	actor IDREF #REQUIRED
	fromActor IDREF #REQUIRED
	fromAttribute CDATA #REQUIRED
>
<!--Disconnects a previously connected attribute.-->
<!ELEMENT disconnect EMPTY>
<!ATTLIST disconnect
	attributeName CDATA #REQUIRED
	actor IDREF #REQUIRED
>
<!ELEMENT control EMPTY>
<!ATTLIST control
	attributeName CDATA #REQUIRED
	actor IDREF #REQUIRED
	min CDATA #IMPLIED
	max CDATA #IMPLIED
	label CDATA #IMPLIED
>
