/* ========================================================================
 * Copyright (C) 2000-2003  Vienna University of Technology
 *
 * This framework is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This framework is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this framework; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 * For further information please contact Dieter Schmalstieg under
 * <schmalstieg@ims.tuwien.ac.at> or write to Dieter Schmalstieg,
 * Vienna University of Technology, Favoritenstr. 9-11/188, A1040 Vienna,
 * Austria.
 * ========================================================================
 * PROJECT: Studierstube
 * ======================================================================== */
//  PROJECT:    Studierstube
//  CONTENT:    Prototypes for Inventor file tools
//  VERSION:    2.0
// ===========================================================================
//  AUTHORS:    az      Andreas Zajic
//              mk      Markus Krutz
//              gh      Gerd Hesina
//              ds      Dieter Schmalstieg
// ===========================================================================
//  HISTORY:
//
// ===========================================================================

#ifndef __IVIO_H__
#define __IVIO_H__

#include <Inventor/SoPath.h>
#include <Inventor/nodes/SoSeparator.h>
#include <stbapi/stbapi.h>

STBAPI_API void writeFile(             //write scengraph to file
    const char* filename,              //name of file
    SoNode* node,                       //root of scenegraph
    SbBool withImages = TRUE
    );

/** 
 * This utility function writes a scenegraph represented by a node into a
 * memory buffer. The memory buffer is allocated and resized as necessary 
 * during writing. The caller owns the buffer, i.e. it has to take care to
 * delete the memory again.
 * @param node pointer to the node to write out
 * @param size pointer to a variable used to store the final size of the buffer
 * @param initSize initial size of the memory buffer. use this to avoid frequent
 *        reallocation, if you know that the graph is large
 * @param binary write either in binary (=TRUE) or ascii (=FALSE) format
 * @param withImages Whether to copy image textures.
 * @return pointer to the memory buffer
 */
STBAPI_API char * writeMemory( SoNode * node, size_t * size, size_t initSize  = 1024, 
                               SbBool binary = TRUE, SbBool withImages = TRUE );

/** 
 * This utility function writes a scenegraph represented by a node into a
 * memory buffer passed by the client. The memory buffer is resized as necessary 
 * during writing. The caller owns the buffer, i.e. it has to take care to
 * delete the memory again. Use this version, if you want to avoid frequent 
 * allocations.
 * @param node pointer to the node to write out
 * @param buffer pointer to pointer to the buffer to write into. This will be
 *        modified if the buffer needs to be extended.
 * @param bufferSize pointer to initial size of the memory buffer. This will be
 *        modified if the buffer needs to be extended.
 * @param offset offset into the buffer, where to start writing
 * @param binary write either in binary (=TRUE) or ascii (=FALSE) format
 * @param withImages Whether to copy image textures.
 * @return size of the written buffer data
 */
STBAPI_API size_t writeBuffer( SoNode * node, void ** buffer, size_t * bufferSize, size_t offset = 0,
                               SbBool binary = TRUE, SbBool withImages = TRUE );

/**
 * This utility function creates a clone of a scenegraph. In addition to the
 * standard copy method of Inventor it switches all image fields of SoTexture2
 * nodes from default to copy their content as well. Then it switches them back
 * to default. This behaviour is controlled by the withImages parameter.
 * @param node The node to copy 
 * @param copyConnections Whether to copy the node's connections. 
 * @param withImages Whether to clone the image information as well.
 * @return A pointer to the new copy
 */
STBAPI_API SoNode * copyNode( SoNode * node, SbBool copyConnections = TRUE, SbBool withImages = TRUE);

/**
 * This utility function finds a file relative to the directories stored
 * in SoInput and also checks, if it is a valid Open Inventor file. It
 * returns the full path name as generated by the SoInput class. The function
 * is useful to search for other files than Inventor files with the
 * same semantics as SoInput does.
 * @param name input/output parameter, contains the filename on input
 *             and the full path/filename on output
 * @param isValid output parameter set to TRUE if the file is a valid Open Inventor file
 * @return TRUE if a file could be found. FALSE otherwise. In the FALSE case
 *         name will not have changed and isValid is set to FALSE.
 */
STBAPI_API SbBool checkFile( SbString & name, SbBool & isValid );

STBAPI_API SoSeparator* readFile(      //read scene from file, returns: root
    const char* filename               //name of file
    );

STBAPI_API SoSeparator* readFile(      //read scene from file, returns: root
    const char* filename,              //name of file
    const char* path                   //search path
    );

STBAPI_API SoSeparator* readMemory(    //read scene from memory, returns: root
    const char* buffer,                //pointer to memory buffer
    size_t len                         //pointer length
    );

STBAPI_API SoSeparator* readMemory(    //read scene from memory, returns: root
    const char* buffer                //pointer to memory buffer
    );


STBAPI_API SoNode* readNodeFromFile(   //read one node (+ children) from file
    const char* filename,              //pointer to memory buffer
    const char* path                   //search path
    );

STBAPI_API SoNode* readNodeFromFile(   //read one node (+ children) from file
    const char* filename               //pointer to memory buffer
    );

STBAPI_API SoNode* readNodeFromMemory( //read 1 node (+ children) from memory
    const char* buffer,                //pointer to memory buffer
    size_t len
    );

STBAPI_API SoNode* readNodeFromMemory( //read 1 node (+ children) from memory
    const char* buffer                 //pointer to memory buffer
    );

STBAPI_API SoNode* findNode(           // finds a node with name <name> in
    SoNode* root,                      // scene graph with root node <root>
    SbString name
    );

STBAPI_API void printNode(
    SoNode* node,
	SbString comment = SbString("")
	);

STBAPI_API void printPath(
    SoPath* path,
	SbString comment = SbString("")
	);

void writeTexture(SoAction *action, SoNode *node);

/**
 * This function replaces recursively SoFile nodes with a group node holding 
 * their contents. It can be configured with a maximal depth in the scene graph and
 * a list of types that denotes node types that also stop the search.
 * @param scene the scene graph to be manipulated, this graph will be 
 *              changed
 * @param depth the maximum depth to go into. If 0 then it will traverse the full graph
 * @param stopTypes a list of node types that the function will treat as leave nodes.
 * @returns the number of SoFile nodes that were replaced.
 */
STBAPI_API unsigned int replaceFileNodes( SoNode * scene, unsigned int depth = 1, const SoTypeList * stopTypes = NULL);
#endif
