<?xml version="1.0" encoding="UTF-8"?>
<!-- This is a simple stylesheet that will convert a QT 3.0 Designer xml form file into a PipSheet.
   The following mappings are done :
     QDialog -> A PipSheetKit with some help geometry
     QTabWidget, QWidget -> create several groups of widgets separated to be used as tab sheets
     QButtonGroup -> Separator (for RadioButton etc.)
     QRadioButton -> SoRadioButton
     QCheckBox -> SoToggleButton
     QPushButton -> SoPushButton
     QLabel -> Some geometry for a text label
     QListBox -> SoListBox with items preset
      
     There is a global variable called height that allows you to fix the 
       height of all widgets on the sheet.
     The PipSheet will be scaled so that the larger dimension will have 
       a length of 1 and all lengths are scaled accordingly. If the parameter
       absolutescale is set to a space separated pair of numbers, the sheets 
       will be scaled to reside within a rectangle of the given size.
     Labels will switch between a text and an image version, if a pixmap property 
       is found in the QLabel element.
     Buttons are able to present both images and text. 
     If a background color is specified it is used for the geometry of the 
       widget. For highlighting it is automatically averaged with the color 
       white (1 1 1). Otherwise a default highlight color is used that can
       be specified as a global variable.
     A darker background color is used for pressed state. It is either 
       generated by halving the values of the background color or using 
       the a default pressed color.
       
     To use images do the following in the QT Designer :
       Set the form properties to use a function (! not inline images !)
       Then give the filename of the image file as the pixmap property of the image.
       (sorry there is no way to preview that in designer :/)
              
 Gerhard Reitmayr <reitmayr@ims.tuwien.ac.at>
       
 $Id: qt2pip.xsl 3427 2004-07-14 12:20:49Z tamer $
-->
<?xmlspysamplexml E:\tools\qt2pip\test.ui?>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:fo="http://www.w3.org/1999/XSL/Format">
  <xsl:output method="text" encoding="ASCII"/>
  <!-- some global variables -->
  <!-- the default height of all widgets-->
  <xsl:param name="absolutescale"/>
  <xsl:param name="height" select="0.1"/>
  <xsl:param name="text_height_off" select="0.501"/>
  <xsl:param name="text_height_on" select="0.101"/>
  <!-- font parameters -->
  <xsl:param name="fontname"/>
  <!-- test mode -->
  <xsl:param name="testmode"/>
  <!-- highlight default color -->
  <xsl:param name="highlight_default_color">0.7 0.7 0.7</xsl:param>
  <!-- pressed default color -->
  <xsl:param name="pressed_default_color">0.3 0.3 0.3</xsl:param>
  <!-- what to put into the geometry parts of different widgets -->
  <!-- geometry for push buttons -->
  <xsl:variable name="pushbutton_off">USE __OFF_GEOM</xsl:variable>
  <xsl:variable name="pushbutton_on">USE __ON_GEOM</xsl:variable>
  <xsl:variable name="pushbutton_off_hl">USE __OFF_HL_GEOM</xsl:variable>
  <xsl:variable name="pushbutton_on_hl">USE __ON_HL_GEOM</xsl:variable>
  <!-- default height for text label geometry -->
  <xsl:variable name="pushbutton_height_off" select="$text_height_off"/>
  <xsl:variable name="pushbutton_height_on" select="$text_height_on"/>
  <!-- geometry for toggle buttons -->
  <xsl:variable name="togglebutton_off">USE __OFF_GEOM</xsl:variable>
  <xsl:variable name="togglebutton_on">USE __ON_GEOM</xsl:variable>
  <xsl:variable name="togglebutton_off_hl">USE __OFF_HL_GEOM</xsl:variable>
  <xsl:variable name="togglebutton_on_hl">USE __ON_HL_GEOM</xsl:variable>
  <!-- default height for text label geometry -->
  <xsl:variable name="togglebutton_height_off" select="$text_height_off"/>
  <xsl:variable name="togglebutton_height_on" select="$text_height_on"/>
  <!-- geometry for radio buttons -->
  <xsl:variable name="radiobutton_off">USE __OFF_GEOM</xsl:variable>
  <xsl:variable name="radiobutton_on">USE __ON_GEOM</xsl:variable>
  <xsl:variable name="radiobutton_off_hl">USE __OFF_HL_GEOM</xsl:variable>
  <xsl:variable name="radiobutton_on_hl">USE __ON_HL_GEOM</xsl:variable>
  <!-- default height for text label geometry -->
  <xsl:variable name="radiobutton_height_off" select="$text_height_off"/>
  <xsl:variable name="radiobutton_height_on" select="$text_height_on"/>
  <!-- geometry for listbox buttons -->
  <xsl:variable name="listbox_off">USE __OFF_GEOM</xsl:variable>
  <xsl:variable name="listbox_on">USE __ON_GEOM</xsl:variable>
  <xsl:variable name="listbox_off_hl">USE __OFF_HL_GEOM</xsl:variable>
  <xsl:variable name="listbox_on_hl">USE __ON_HL_GEOM</xsl:variable>
  <!-- default height for text label geometry -->
  <xsl:variable name="listbox_height_off" select="$text_height_off"/>
  <xsl:variable name="listbox_height_on" select="$text_height_on"/>
  <!-- geometry for slider -->
  <xsl:variable name="slider_static">USE __SLIDER_STATIC_GEOM</xsl:variable>
  <xsl:variable name="slider_knob">USE __SLIDER_KNOB_GEOM</xsl:variable>
  <!-- some derived global variables -->
  <xsl:variable name="gx">
    <xsl:choose>
      <xsl:when test="$absolutescale">
        <xsl:value-of select="substring-before(normalize-space($absolutescale),' ')"/>
      </xsl:when>
      <xsl:otherwise>1</xsl:otherwise>
    </xsl:choose>
  </xsl:variable>
  <xsl:variable name="gy">
    <xsl:choose>
      <xsl:when test="$absolutescale">
        <xsl:value-of select="substring-after(normalize-space($absolutescale),' ')"/>
      </xsl:when>
      <xsl:otherwise>1</xsl:otherwise>
    </xsl:choose>
  </xsl:variable>
  <!-- We generate a PipSheet  from a QDialog class (or any other in the future :)-->
  <xsl:template match="widget[@class='QDialog']">
    <!-- compute the scale factor for all future measurements -->
    <xsl:param name="scalefactor">
      <xsl:choose>
        <xsl:when test="(property[@name='geometry']/rect/width div $gx)> (property[@name='geometry']/rect/height div $gy)">
          <xsl:value-of select="property[@name='geometry']/rect/width div $gx"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:value-of select="property[@name='geometry']/rect/height div $gy"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:param>#Inventor V2.1 ascii
  <xsl:if test="$testmode">SoApplicationKit {
      contextKit SoContextKit {
        templatePipSheet</xsl:if>
# PipSheet <xsl:value-of select="property[@name='name']/cstring"/> (autogenerated by qt2pip.xsl)
SoPipSheetKit {
	# pipParts (PIP_BODY|SHEET|SHEET_TABS|SYSTEM_TABS)
	<xsl:choose>
      <xsl:when test="$absolutescale">autoScaling FALSE</xsl:when>
      <xsl:otherwise># autoScaling FALSE</xsl:otherwise>
    </xsl:choose>
	# sheetsRoot So3DSeparator { boundingBoxCheck FALSE eventMask BM_ALL_EVENTS }
	sheets Switch {
     Separator {         # 1. sheet
    <!-- this switch stores reusable geometry for buttons. If you want different geometry, replace or add stuff here -->     				
    # this switch stores reusable button geometry as invisible geometry. it should not be traversed !
    Switch {  whichChild -1
    DEF __OFF_GEOM Separator {    
    ShapeHints {
        vertexOrdering  COUNTERCLOCKWISE
        creaseAngle 1.36136
    }
    Coordinate3 {
        point [ -0.5 -0.5 -0.5,
                -0.5 0.4 -0.5,
                0.5 0.4 -0.5,
                0.5 -0.5 -0.5,
                -0.5 0.4 0.5,
                -0.5 -0.5 0.5,
                0.5 0.4 0.5,
                0.5 -0.5 0.5,
                -0.36444 0.5 -0.348644,
                -0.363032 0.5 0.354509,
                0.353259 0.5 0.350574,
                0.354633 0.5 -0.344963,
                -0.3 0.5 -0.3,
                -0.3 0.5 0.3,
                0.3 0.5 0.3,
                0.3 0.5 -0.3 ]
    }
    TextureCoordinateBinding {value PER_VERTEX}
    TextureCoordinate2 {point [0 0, 0 1, 1 1 , 0 0, 1 1 , 1 0]}
    IndexedFaceSet {
        coordIndex  [ 12, 13, 14, -1, 12, 14, 15, -1 ]
    }
    SoTexture2 {}
    IndexedFaceSet {       
        coordIndex  [ 12, 11, 8, -1, 15, 11, 12, -1,
              15, 14, 11, -1, 14, 10, 11, -1,
              14, 9, 10, -1, 13, 9, 14, -1,
              13, 8, 9, -1, 12, 8, 13, -1,
              8, 11, 1, -1, 11, 2, 1, -1,
              11, 10, 2, -1, 10, 6, 2, -1,
              10, 4, 6, -1, 9, 4, 10, -1,
              9, 1, 4, -1, 8, 1, 9, -1,
              7, 5, 3, -1, 5, 0, 3, -1,
              6, 7, 2, -1, 7, 3, 2, -1,
              5, 4, 1, -1, 0, 5, 1, -1,
              6, 5, 7, -1, 4, 5, 6, -1,
              0, 2, 3, -1, 0, 1, 2, -1 ]
    }    
    }

    DEF __ON_GEOM Separator {
    ShapeHints {
        vertexOrdering  COUNTERCLOCKWISE
        creaseAngle 1.36136
    }
    Coordinate3 {
        point [ -0.5 -0.5 -0.5,
                -0.5 0.0 -0.5,
                0.5 0.0 -0.5,
                0.5 -0.5 -0.5,
                -0.5 0.0 0.5,
                -0.5 -0.5 0.5,
                0.5 0.0 0.5,
                0.5 -0.5 0.5,
                -0.36444 0.1 -0.348644,
                -0.363032 0.1 0.354509,
                0.353259 0.1 0.350574,
                0.354633 0.1 -0.344963,
                -0.3 0.1 -0.3,
                -0.3 0.1 0.3,
                0.3 0.1 0.3,
                0.3 0.1 -0.3 ]
    }
    TextureCoordinateBinding {value PER_VERTEX}
    TextureCoordinate2 {point [0 0, 0 1, 1 1 , 0 0, 1 1 , 1 0]}
    IndexedFaceSet {
        coordIndex  [ 12, 13, 14, -1, 12, 14, 15, -1 ]
    }
    SoTexture2 {}
    IndexedFaceSet {       
        coordIndex  [ 12, 11, 8, -1, 15, 11, 12, -1,
              15, 14, 11, -1, 14, 10, 11, -1,
              14, 9, 10, -1, 13, 9, 14, -1,
              13, 8, 9, -1, 12, 8, 13, -1,
              8, 11, 1, -1, 11, 2, 1, -1,
              11, 10, 2, -1, 10, 6, 2, -1,
              10, 4, 6, -1, 9, 4, 10, -1,
              9, 1, 4, -1, 8, 1, 9, -1,
              7, 5, 3, -1, 5, 0, 3, -1,
              6, 7, 2, -1, 7, 3, 2, -1,
              5, 4, 1, -1, 0, 5, 1, -1,
              6, 5, 7, -1, 4, 5, 6, -1,
              0, 2, 3, -1, 0, 1, 2, -1 ]
    }
    }

  DEF __OFF_HL_GEOM Separator {
   ShapeHints {
        vertexOrdering  COUNTERCLOCKWISE
        creaseAngle 1.36136
    }
    Coordinate3 {
        point [ -0.5 -0.5 -0.5,
                -0.5 0.4 -0.5,
                0.5 0.4 -0.5,
                0.5 -0.5 -0.5,
                -0.5 0.4 0.5,
                -0.5 -0.5 0.5,
                0.5 0.4 0.5,
                0.5 -0.5 0.5,
                -0.36444 0.5 -0.348644,
                -0.363032 0.5 0.354509,
                0.353259 0.5 0.350574,
                0.354633 0.5 -0.344963,
                -0.3 0.5 -0.3,
                -0.3 0.5 0.3,
                0.3 0.5 0.3,
                0.3 0.5 -0.3 ]
    }
    TextureCoordinateBinding {value PER_VERTEX}
    TextureCoordinate2 {point [0 0, 0 1, 1 1 , 0 0, 1 1 , 1 0]}
    IndexedFaceSet {
        coordIndex  [ 12, 13, 14, -1, 12, 14, 15, -1 ]
    }
    SoTexture2 {}
    IndexedFaceSet {       
        coordIndex  [ 12, 11, 8, -1, 15, 11, 12, -1,
              15, 14, 11, -1, 14, 10, 11, -1,
              14, 9, 10, -1, 13, 9, 14, -1,
              13, 8, 9, -1, 12, 8, 13, -1,
              8, 11, 1, -1, 11, 2, 1, -1,
              11, 10, 2, -1, 10, 6, 2, -1,
              10, 4, 6, -1, 9, 4, 10, -1,
              9, 1, 4, -1, 8, 1, 9, -1,
              7, 5, 3, -1, 5, 0, 3, -1,
              6, 7, 2, -1, 7, 3, 2, -1,
              5, 4, 1, -1, 0, 5, 1, -1,
              6, 5, 7, -1, 4, 5, 6, -1,
              0, 2, 3, -1, 0, 1, 2, -1 ]
    }
    }

DEF __ON_HL_GEOM Separator {
    ShapeHints {
        vertexOrdering  COUNTERCLOCKWISE
        creaseAngle 1.36136
    }
    Coordinate3 {
        point [ -0.5 -0.5 -0.5,
                -0.5 0.0 -0.5,
                0.5 0.0 -0.5,
                0.5 -0.5 -0.5,
                -0.5 0.0 0.5,
                -0.5 -0.5 0.5,
                0.5 0.0 0.5,
                0.5 -0.5 0.5,
                -0.36444 0.1 -0.348644,
                -0.363032 0.1 0.354509,
                0.353259 0.1 0.350574,
                0.354633 0.1 -0.344963,
                -0.3 0.1 -0.3,
                -0.3 0.1 0.3,
                0.3 0.1 0.3,
                0.3 0.1 -0.3 ]
    }
    TextureCoordinateBinding {value PER_VERTEX}
    TextureCoordinate2 {point [0 0, 0 1, 1 1 , 0 0, 1 1 , 1 0]}
    IndexedFaceSet {
        coordIndex  [ 12, 13, 14, -1, 12, 14, 15, -1 ]
    }
    SoTexture2 {}
    IndexedFaceSet {       
        coordIndex  [ 12, 11, 8, -1, 15, 11, 12, -1,
              15, 14, 11, -1, 14, 10, 11, -1,
              14, 9, 10, -1, 13, 9, 14, -1,
              13, 8, 9, -1, 12, 8, 13, -1,
              8, 11, 1, -1, 11, 2, 1, -1,
              11, 10, 2, -1, 10, 6, 2, -1,
              10, 4, 6, -1, 9, 4, 10, -1,
              9, 1, 4, -1, 8, 1, 9, -1,
              7, 5, 3, -1, 5, 0, 3, -1,
              6, 7, 2, -1, 7, 3, 2, -1,
              5, 4, 1, -1, 0, 5, 1, -1,
              6, 5, 7, -1, 4, 5, 6, -1,
              0, 2, 3, -1, 0, 1, 2, -1 ]
    }
    }
DEF __SLIDER_STATIC_GEOM Separator {
           Translation{ translation 0 0.66692 0}
           Coordinate3 {
              point [ -0.5 -0.43692 -0.50000,
                        -0.5 -0.66692 -0.50000,
                        -0.5 -0.43692 0.49999,
                        -0.5 -0.66692 0.49999,
                        0.49999 -0.43692 0.49999,
                        0.49999 -0.66692 0.49999,
                        0.49999 -0.43692 -0.50000,
                        0.49999 -0.66692 -0.50000,
                        0.05436 -0.43692 -0.43868,
                        0.05436 -0.43692 -0.05436,
                        -0.05436 -0.43692 0.05436,
                        -0.05436 -0.43692 -0.43868,
                        -0.05436 -0.43692 0.43868,
                        0.05436 -0.43692 0.43868,
                        0.05436 -0.60898 -0.43868,
                        -0.05436 -0.60898 -0.43868,
                        0.05436 -0.60898 0.43868,
                        -0.05436 -0.60898 0.43868 ]
                }
           IndexedFaceSet {
                coordIndex [ 15,11,12,-1,
                    17,15,12,-1,
                    16,13,8,-1,
                    14,16,8,-1,
                    15,14,11,-1,
                    8,11,14,-1,
                    12,13,17,-1,
                    16,17,13,-1,
                    17,16,15,-1,
                    14,15,16,-1,
                    12,4,13,-1,
                    4,6,13,-1,
                    9,13,6,-1,
                    10,2,12,-1,
                    2,4,12,-1,
                    8,0,11,-1,
                    0,2,11,-1,
                    10,11,2,-1,
                    9,6,8,-1,
                    6,0,8,-1,
                    7,5,1,-1,
                    3,1,5,-1,
                    1,0,7,-1,
                    6,7,0,-1,
                    7,6,5,-1,
                    4,5,6,-1,
                    5,4,3,-1,
                    2,3,4,-1,
                    3,2,1,-1,
                    0,1,2,-1 ]
            }
    }    
    DEF __SLIDER_KNOB_GEOM Separator {
           Translation{ translation 0 0.5 0}
            Coordinate3 {
                    point [
                        -0.37501 -0.20967 0.05001,
                        0.37498 -0.20967 0.05001,
                        0.37498 0.45616 0.03725,
                        -0.37501 0.45616 0.03725,
                        0.37498 0.55032 0.03131,
                        -0.37501 0.55032 0.03131,
                        0.37498 0.55032 0.01232,
                        -0.37501 0.55032 0.01232,
                        -0.37501 0.50100 0.00639,
                        0.37498 0.50100 0.00639,
                        0.37498 0.50100 -0.00607,
                        -0.37501 0.50100 -0.00607,
                        0.37498 0.54361 -0.01289,
                        -0.37501 0.54361 -0.01289,
                        0.37498 0.54361 -0.03069,
                        -0.37501 0.54361 -0.03069,
                        0.37498 0.45393 -0.03782,
                        -0.37501 0.45393 -0.03782,
                        0.37498 -0.20745 -0.04998,
                        -0.37501 -0.20745 -0.04998
                        ]
                }
           IndexedFaceSet {
                coordIndex [
                    8,19,0,-1,
                    7,8,0,-1,
                    3,5,7,-1,
                    0,3,7,-1,
                    17,8,11,-1,
                    17,19,8,-1,
                    11,15,17,-1,
                    11,13,15,-1,
                    18,9,1,-1,
                    9,6,1,-1,
                    4,2,6,-1,
                    2,1,6,-1,
                    9,16,10,-1,
                    18,16,9,-1,
                    14,10,16,-1,
                    12,10,14,-1,
                    0,19,1,-1,
                    19,18,1,-1,
                    19,17,18,-1,
                    17,16,18,-1,
                    17,15,16,-1,
                    15,14,16,-1,
                    15,13,14,-1,
                    13,12,14,-1,
                    13,11,12,-1,
                    11,10,12,-1,
                    11,8,10,-1,
                    8,9,10,-1,
                    8,6,9,-1,
                    7,6,8,-1,
                    7,5,6,-1,
                    5,4,6,-1,
                    5,3,4,-1,
                    3,2,4,-1,
                    3,0,2,-1,
                    0,1,2,-1
                    ]
            }
    }
    }
	<!-- a fixed rotation to get everything parallel to the pip :/ -->
	  Transform {  rotation 1 0 0 1.57  <xsl:if test="$absolutescale">translation -<xsl:value-of select="$gx div 2"/> +<xsl:value-of select="$gy div 2"/> 0</xsl:if> }
      <xsl:apply-templates mode="default">
      <xsl:with-param name="scalefactor" select="$scalefactor"/>
    </xsl:apply-templates>
    }
    }
    <!-- tab button texture list here -->
    <xsl:if test=".//widget[@class='QTabWidget']/property[@name='whatsThis']/string">
    tabTextures [
        <xsl:call-template name="tabTextureNames">
        <xsl:with-param name="list" select="normalize-space(.//widget[@class='QTabWidget']/property[@name='whatsThis']/string)"/>
      </xsl:call-template>
    ]</xsl:if>
}    # end of autogenerated pip sheet

<xsl:if test="$testmode">} }  # closing test mode  applicationkit
</xsl:if>
  </xsl:template>
  <!-- A QTabWidget will trigger the creation of several Separators for the different tabs -->
  <xsl:template match="widget[@class='QTabWidget']" mode="default">
    <xsl:param name="scalefactor" select="1"/>
    <xsl:for-each select="./widget[@class='QWidget']">
      <xsl:apply-templates mode="default">
        <xsl:with-param name="scalefactor" select="$scalefactor"/>
      </xsl:apply-templates>
      <xsl:if test="not(position()=last())">}
      Separator {          # next sheet
          Transform {  rotation 1 0 0 1.57  <xsl:if test="$absolutescale">translation -<xsl:value-of select="$gx div 2"/> +<xsl:value-of select="$gy div 2"/> 0</xsl:if> }</xsl:if>
    </xsl:for-each>
  </xsl:template>
  <!-- A ButtonGroup will be translated into a Separator with some Transformation to get it correct -->
  <xsl:template match="widget[@class='QButtonGroup']|widget[@class='QGroupBox']" mode="default">
    <xsl:param name="scalefactor" select="1"/>
	Separator {					 # begin button group
		<xsl:apply-templates mode="group" select="property">
      <xsl:with-param name="scalefactor" select="$scalefactor"/>
    </xsl:apply-templates>
    <xsl:apply-templates mode="default">
      <xsl:with-param name="scalefactor" select="$scalefactor"/>
    </xsl:apply-templates>
	} 		     					 # end button group
	</xsl:template>
  <!-- A QRatioButton is mapped to a SoRadioButton-->
  <xsl:template match="widget[@class='QRadioButton']" mode="default">
    <xsl:param name="scalefactor" select="1"/>
	      					# SoRadioButton <xsl:value-of select="property[@name='name']/cstring"/>
    <xsl:text>
		</xsl:text>
    <xsl:apply-templates mode="widget">
      <xsl:with-param name="scalefactor" select="$scalefactor"/>
    </xsl:apply-templates>
		DEF <xsl:value-of select="property[@name='name']/cstring"/> SoRadioButton {
			width <xsl:value-of select="property[@name='geometry']/rect/width div $scalefactor"/>
			height <xsl:value-of select="$height"/>
			depth <xsl:value-of select="property[@name='geometry']/rect/height div $scalefactor"/>
			
			offGeometry Separator {
				<xsl:if test="property[@name='pixmap']">DEF __IMAGE Texture2 { filename "<xsl:value-of select="property[@name='pixmap']"/>" }
				</xsl:if>
    <xsl:apply-templates mode="backgroundcolor"/>
    <xsl:value-of select="$radiobutton_off"/>
    <xsl:if test="string(property[@name='text']/string)">
				Transform { translation 0 <xsl:value-of select="$radiobutton_height_off"/> 0.25 rotation 1 0 0 -1.57 }
				<xsl:call-template name="createLabel">
        <xsl:with-param name="line" select="property[@name='text']/string"/>
        <xsl:with-param name="textscale" select="0.5"/>
      </xsl:call-template>
    </xsl:if>
			}
			onGeometry Separator {
				<xsl:if test="property[@name='pixmap']">USE __IMAGE
				</xsl:if>
    <xsl:call-template name="background_pressed_color"/>
    <xsl:value-of select="$radiobutton_on"/>
    <xsl:if test="string(property[@name='text']/string)">
				Transform { translation 0 <xsl:value-of select="$radiobutton_height_on"/> 0.25 rotation 1 0 0 -1.57 }
				USE __LABEL</xsl:if>
			}
			highlightedOffGeometry Separator {
				<xsl:if test="property[@name='pixmap']">USE __IMAGE
				</xsl:if>
    <xsl:call-template name="background_highlight_color"/>
    <xsl:value-of select="$radiobutton_off_hl"/>
    <xsl:if test="string(property[@name='text']/string)">
				Transform { translation 0 <xsl:value-of select="$radiobutton_height_off"/> 0.25 rotation 1 0 0 -1.57 }
				USE __LABEL</xsl:if>
			}
			highlightedOnGeometry Separator {
				<xsl:if test="property[@name='pixmap']">USE __IMAGE
				</xsl:if>
    <xsl:call-template name="background_highlight_color"/>
    <xsl:value-of select="$radiobutton_on_hl"/>
    <xsl:if test="string(property[@name='text']/string)">
				Transform { translation 0 <xsl:value-of select="$radiobutton_height_on"/> 0.25 rotation 1 0 0 -1.57 }
				USE __LABEL</xsl:if>
			}
		}
          <xsl:apply-templates mode="widget_inverse">
      <xsl:with-param name="scalefactor" select="$scalefactor"/>
    </xsl:apply-templates>
  </xsl:template>
  <!-- A QCheckBox is mapped to a SoToggleButton -->
  <xsl:template match="widget[@class='QCheckBox']" mode="default">
    <xsl:param name="scalefactor" select="1"/>
	Separator {					# SoToggleButton <xsl:value-of select="property[@name='name']/cstring"/>
    <xsl:text>
		</xsl:text>
    <xsl:apply-templates mode="widget">
      <xsl:with-param name="scalefactor" select="$scalefactor"/>
    </xsl:apply-templates>
		DEF <xsl:value-of select="property[@name='name']/cstring"/> SoToggleButton {
			width <xsl:value-of select="property[@name='geometry']/rect/width  div $scalefactor"/>
			height <xsl:value-of select="$height"/>
			depth <xsl:value-of select="property[@name='geometry']/rect/height  div $scalefactor"/>
			
			offGeometry Separator {
				<xsl:if test="property[@name='pixmap']">DEF __IMAGE Texture2 { filename "<xsl:value-of select="property[@name='pixmap']"/>" }
				</xsl:if>
    <xsl:apply-templates mode="backgroundcolor"/>
    <xsl:value-of select="$togglebutton_off"/>
    <xsl:if test="string(property[@name='text']/string)">
				Transform { translation 0 <xsl:value-of select="$togglebutton_height_off"/> 0.25 rotation 1 0 0 -1.57 }
      		<xsl:call-template name="createLabel">
        <xsl:with-param name="line" select="property[@name='text']/string"/>
        <xsl:with-param name="textscale" select="0.5"/>
      </xsl:call-template>
    </xsl:if>
			}
			onGeometry Separator {
				<xsl:if test="property[@name='pixmap']">USE __IMAGE
				</xsl:if>
    <xsl:call-template name="background_pressed_color"/>
    <xsl:value-of select="$togglebutton_on"/>
    <xsl:if test="string(property[@name='text']/string)">
				Transform { translation 0 <xsl:value-of select="$togglebutton_height_on"/> 0.25 rotation 1 0 0 -1.57 }
				USE __LABEL</xsl:if>
			}
			highlightedOffGeometry Separator {
				<xsl:if test="property[@name='pixmap']">USE __IMAGE
				</xsl:if>
    <xsl:call-template name="background_highlight_color"/>
    <xsl:value-of select="$togglebutton_off_hl"/>
    <xsl:if test="string(property[@name='text']/string)">
				Transform { translation 0 <xsl:value-of select="$togglebutton_height_off"/> 0.25 rotation 1 0 0 -1.57 }
				USE __LABEL</xsl:if>
			}
			highlightedOnGeometry Separator {
				<xsl:if test="property[@name='pixmap']">USE __IMAGE
				</xsl:if>
    <xsl:call-template name="background_highlight_color"/>
    <xsl:value-of select="$togglebutton_on_hl"/>
    <xsl:if test="string(property[@name='text']/string)">
				Transform { translation 0 <xsl:value-of select="$togglebutton_height_on"/> 0.25 rotation 1 0 0 -1.57 }
				USE __LABEL</xsl:if>
			}			
		}
	}
	</xsl:template>
  <!-- A QPushButton is mapped to a SoPushButton -->
  <xsl:template match="widget[@class='QPushButton']" mode="default">
    <xsl:param name="scalefactor" select="1"/>
	Separator {					# SoPushButton <xsl:value-of select="property[@name='name']/cstring"/>
    <xsl:text>
		</xsl:text>
    <xsl:apply-templates mode="widget" select="property[@name='geometry']">
      <xsl:with-param name="scalefactor" select="$scalefactor"/>
    </xsl:apply-templates>
		DEF <xsl:value-of select="property[@name='name']/cstring"/> SoPushButton {
			width <xsl:value-of select="property[@name='geometry']/rect/width  div $scalefactor"/>
			height <xsl:value-of select="$height"/>
			depth <xsl:value-of select="property[@name='geometry']/rect/height  div $scalefactor"/>
			
			offGeometry Separator {
				<xsl:if test="property[@name='pixmap']">DEF __IMAGE Texture2 { filename "<xsl:value-of select="property[@name='pixmap']"/>" }
				</xsl:if>
    <xsl:apply-templates mode="backgroundcolor"/>
    <xsl:value-of select="$pushbutton_off"/>
    <xsl:if test="string(property[@name='text']/string)">
				Transform { translation 0 <xsl:value-of select="$pushbutton_height_off"/> 0.25 rotation 1 0 0 -1.57 }
		<xsl:call-template name="createLabel">
        <xsl:with-param name="line" select="property[@name='text']/string"/>
        <xsl:with-param name="textscale" select="0.5"/>
      </xsl:call-template>
    </xsl:if>
			}
			onGeometry Separator {
				<xsl:if test="property[@name='pixmap']">USE __IMAGE
				</xsl:if>
    <xsl:call-template name="background_pressed_color"/>
    <xsl:value-of select="$pushbutton_on"/>
    <xsl:if test="string(property[@name='text']/string)">
				Transform { translation 0 <xsl:value-of select="$pushbutton_height_on"/> 0.25 rotation 1 0 0 -1.57 }
				USE __LABEL</xsl:if>
			}
			highlightedOffGeometry Separator {
				<xsl:if test="property[@name='pixmap']">USE __IMAGE
				</xsl:if>
    <xsl:call-template name="background_highlight_color"/>
    <xsl:text>
				</xsl:text>
    <xsl:value-of select="$pushbutton_off_hl"/>
    <xsl:if test="string(property[@name='text']/string)">
				Transform { translation 0 <xsl:value-of select="$pushbutton_height_off"/> 0.25 rotation 1 0 0 -1.57 }
				USE __LABEL</xsl:if>
			}
			highlightedOnGeometry Separator {			
				<xsl:if test="property[@name='pixmap']">USE __IMAGE
				</xsl:if>
    <xsl:call-template name="background_highlight_color"/>
    <xsl:text>
				</xsl:text>
    <xsl:value-of select="$pushbutton_on_hl"/>
    <xsl:if test="string(property[@name='text']/string)">
				Transform { translation 0 <xsl:value-of select="$pushbutton_height_on"/> 0.25 rotation 1 0 0 -1.57 }
				USE __LABEL</xsl:if>
			}
		}
	}
	</xsl:template>
  <!-- A QLabel is mapped to a some geometry displaying the label ! -->
  <xsl:template match="widget[@class='QLabel']" mode="default">
    <xsl:param name="scalefactor" select="1"/>
    <!-- if a pixmap property is present, then we do an image label, otherwise a text label ! -->
    <xsl:choose>
      <xsl:when test="property[@name='pixmap']">
	Separator {					# Image Label <xsl:value-of select="property[@name='name']/cstring"/>
        <xsl:text>
		</xsl:text>
        <xsl:apply-templates mode="group">
          <xsl:with-param name="scalefactor" select="$scalefactor"/>
        </xsl:apply-templates>
		Transform { scaleFactor <xsl:value-of select="property[@name='geometry']/rect/width div $scalefactor"/> 1 <xsl:value-of select="property[@name='geometry']/rect/height div $scalefactor"/> translation 0 -<xsl:value-of select="$height div 2"/> 0 }
		<xsl:apply-templates mode="backgroundcolor"/>
		Texture2 { filename "<xsl:value-of select="property[@name='pixmap']"/>" }
		Coordinate3 { point [0 0 0, 1 0 0, 1 0 1, 0 0 1] }
		TextureCoordinateBinding { value PER_VERTEX }
		TextureCoordinate2 { point [ 0 0, 0 1, 1 1, 1 0 ] }
		IndexedFaceSet { coordIndex [ 0, 3, 2, 1, -1 ] }			
	}		
		</xsl:when>
      <xsl:otherwise>
	Separator {					# Text Label <xsl:value-of select="property[@name='name']/cstring"/>
        <xsl:if test="property[@name='paletteBackgroundColor']">
	   Separator {					# colored background surface, also good for bounding box calcs.
        <xsl:text>
		</xsl:text>
          <xsl:apply-templates mode="group">
            <xsl:with-param name="scalefactor" select="$scalefactor"/>
          </xsl:apply-templates>
		Transform { scaleFactor <xsl:value-of select="property[@name='geometry']/rect/width div $scalefactor"/> 1 <xsl:value-of select="property[@name='geometry']/rect/height div $scalefactor"/> translation 0 -<xsl:value-of select="$height div 2"/> 0 }
		<xsl:apply-templates mode="backgroundcolor"/>
		Coordinate3 { point [0 0 0, 1 0 0, 1 0 1, 0 0 1] }
		IndexedFaceSet { coordIndex [ 0, 3, 2, 1, -1 ] }			
	}
	</xsl:if>
        <xsl:text>
		</xsl:text>
        <xsl:variable name="textscale">
          <xsl:choose>
            <xsl:when test="property[@name='toolTip']/string = 'vertical'">
              <xsl:value-of select="(property[@name='geometry']/rect/width div 2) div $scalefactor"/>
            </xsl:when>
            <xsl:otherwise>
              <xsl:value-of select="(property[@name='geometry']/rect/height div 2) div $scalefactor"/>
            </xsl:otherwise>
          </xsl:choose>
        </xsl:variable>
        <xsl:variable name="offsetlen">
          <xsl:choose>
            <xsl:when test="property[@name='toolTip']/string = 'vertical'">
              <xsl:value-of select="(property[@name='geometry']/rect/height div 2) div $scalefactor"/>
            </xsl:when>
            <xsl:otherwise>
              <xsl:value-of select="(property[@name='geometry']/rect/width div 2) div $scalefactor"/>
            </xsl:otherwise>
          </xsl:choose>
        </xsl:variable>
        <xsl:variable name="offset">
          <xsl:choose>
            <xsl:when test="contains(property[@name='alignment']/set,'AlignLeft')">
              <xsl:value-of select="-1 * $offsetlen"/>
            </xsl:when>
            <xsl:when test="contains(property[@name='alignment']/set,'AlignRight')">
              <xsl:value-of select="$offsetlen"/>
            </xsl:when>
            <xsl:otherwise>0</xsl:otherwise>
          </xsl:choose>
        </xsl:variable>
        <xsl:apply-templates mode="widget">
          <xsl:with-param name="scalefactor" select="$scalefactor"/>
        </xsl:apply-templates>
        <xsl:if test="property[@name='toolTip']/string = 'vertical'">
        Transform { rotation 0 1 0 1.57 }</xsl:if>
        Transform { translation <xsl:value-of select="$offset"/> -<xsl:value-of select="$height div 2"/>
        <xsl:text> </xsl:text>
        <xsl:value-of select="$textscale div 2"/> rotation 1 0 0 -1.57 }
		<xsl:call-template name="createLabel">
          <xsl:with-param name="line" select="property[@name='text']/string"/>
          <xsl:with-param name="textscale" select="$textscale"/>
          <xsl:with-param name="defname" select="property[@name='name']/cstring"/>
          <xsl:with-param name="justify">
            <xsl:choose>
              <xsl:when test="contains(property[@name='alignment']/set,'AlignLeft')">LEFT</xsl:when>
              <xsl:when test="contains(property[@name='alignment']/set,'AlignRight')">RIGHT</xsl:when>
              <xsl:otherwise>CENTER</xsl:otherwise>
            </xsl:choose>
          </xsl:with-param>
          <xsl:with-param name="connection" select="property[@name='whatsThis']/string"/>
        </xsl:call-template>
	}
		</xsl:otherwise>
    </xsl:choose>
  </xsl:template>
  <!-- A QSlider is mapped to a SoSlider 
	      the orientation field is mapped to a rotation and only value, maxValue and minValue are used. -->
  <xsl:template match="widget[@class='QSlider']" mode="default">
    <xsl:param name="scalefactor" select="1"/>
		Separator {					# SoSlider <xsl:value-of select="property[@name='name']/cstring"/>
    <xsl:text>
		</xsl:text>
    <xsl:apply-templates mode="widget" select="property[@name='geometry']">
      <xsl:with-param name="scalefactor" select="$scalefactor"/>
    </xsl:apply-templates>
    <xsl:choose>
      <xsl:when test="property[@name='orientation']/enum = 'Vertical'">
      Transform { translation 0 -<xsl:value-of select="$height div 2"/> 0 }
  		DEF <xsl:value-of select="property[@name='name']/cstring"/> SoSlider {
			width <xsl:value-of select="property[@name='geometry']/rect/width  div $scalefactor"/>
			height <xsl:value-of select="$height"/>
			depth <xsl:value-of select="property[@name='geometry']/rect/height  div $scalefactor"/>
         minVector 0 0 -<xsl:value-of select="(property[@name='geometry']/rect/height div $scalefactor)*.45"/>
         maxVector 0 0 <xsl:value-of select="(property[@name='geometry']/rect/height div $scalefactor)*.45"/>
        <xsl:text>
         </xsl:text>
      </xsl:when>
      <xsl:otherwise>
      Transform { translation 0 -<xsl:value-of select="$height div 2"/> 0 rotation 0 1 0 1.57 }
  		DEF <xsl:value-of select="property[@name='name']/cstring"/> SoSlider {
			width <xsl:value-of select="property[@name='geometry']/rect/height  div $scalefactor"/>
			height <xsl:value-of select="$height"/>
			depth <xsl:value-of select="property[@name='geometry']/rect/width  div $scalefactor"/>
         minVector 0 0 -<xsl:value-of select="(property[@name='geometry']/rect/width div $scalefactor)*.45"/>
         maxVector 0 0 <xsl:value-of select="(property[@name='geometry']/rect/width div $scalefactor)*.45"/>
        <xsl:text>
         </xsl:text>
      </xsl:otherwise>
    </xsl:choose>
    <xsl:if test="property[@name='minValue']/number">minValue  <xsl:value-of select="property[@name='minValue']/number"/>
      <xsl:text>
			</xsl:text>
    </xsl:if>
    <xsl:if test="property[@name='maxValue']/number">maxValue  <xsl:value-of select="property[@name='maxValue']/number"/>
      <xsl:text>
			</xsl:text>
    </xsl:if>
    <xsl:if test="property[@name='value']/number">
      <xsl:variable name="minValue">
        <xsl:choose>
          <xsl:when test="property[@name='minValue']/number">
            <xsl:value-of select="property[@name='minValue']/number"/>
          </xsl:when>
          <xsl:otherwise>0</xsl:otherwise>
        </xsl:choose>
      </xsl:variable>
      <xsl:variable name="maxValue">
        <xsl:choose>
          <xsl:when test="property[@name='maxValue']/number">
            <xsl:value-of select="property[@name='maxValue']/number"/>
          </xsl:when>
          <xsl:otherwise>20</xsl:otherwise>
        </xsl:choose>
      </xsl:variable>			
			  alphaOutput <xsl:value-of select="(number(property[@name='value']/number)-$minValue) div ($maxValue - $minValue)"/>
      <xsl:text>
			</xsl:text>
    </xsl:if>

			  staticGeometry Separator {
    		    <xsl:apply-templates mode="backgroundcolor"/>
    <xsl:text>
			    </xsl:text>
    <xsl:value-of select="$slider_static"/>
			  }			
			  normalGeometry Separator {
			    <xsl:apply-templates mode="foregroundcolor"/>
    <xsl:text>
			    </xsl:text>
    <xsl:value-of select="$slider_knob"/>
			  }			
			  highlightedGeometry Separator {
			    <xsl:apply-templates mode="foreground_highlight_color"/>
    <xsl:text>
			    </xsl:text>
    <xsl:value-of select="$slider_knob"/>
			  }			 
			  draggedGeometry Separator {
			    <xsl:apply-templates mode="foreground_highlight_color"/>
    <xsl:text>
			    </xsl:text>
    <xsl:value-of select="$slider_knob"/>
			  }
			}
	}
	</xsl:template>
  <!-- A QListBox is mapped to a SoListBox 
	     values are added to the values of the list box -->
  <xsl:template match="widget[@class='QListBox']" mode="default">
    <xsl:param name="scalefactor" select="1"/>
	Separator {					# SoListBox <xsl:value-of select="property[@name='name']/cstring"/>
    <xsl:text>
		</xsl:text>
    <xsl:apply-templates mode="widget" select="property[@name='geometry']">
      <xsl:with-param name="scalefactor" select="$scalefactor"/>
    </xsl:apply-templates>
		DEF <xsl:value-of select="property[@name='name']/cstring"/> SoListBox {
			width <xsl:value-of select="property[@name='geometry']/rect/width  div $scalefactor"/>
			height <xsl:value-of select="$height"/>
			depth <xsl:value-of select="property[@name='geometry']/rect/height  div $scalefactor"/>
        spacing        <xsl:value-of select="property[@name='geometry']/rect/width  div $scalefactor * 0.05"/>  # your desired spacing
        navButtonWidth <xsl:value-of select="property[@name='geometry']/rect/width  div $scalefactor * 0.15"/>   # the width of the navigation buttons
        multipleSelections <xsl:choose>
      <xsl:when test="property[@name='selectionMode']/enum = 'Single'">FALSE</xsl:when>
      <xsl:otherwise>TRUE</xsl:otherwise>
    </xsl:choose>
    <xsl:choose>
      <xsl:when test="$testmode">
        values [ "test1", "test2", "test3","test4","test5","test6","test7" ]</xsl:when>
      <xsl:otherwise>
        <xsl:for-each select="item">
          <xsl:text>
</xsl:text>
          <xsl:value-of select="./property[@name='text']/string"/>
        </xsl:for-each>
      </xsl:otherwise>
    </xsl:choose>
        
        off Separator {
				  <xsl:apply-templates mode="backgroundcolor"/>
    <xsl:value-of select="$listbox_off"/>
				  Transform { translation 0 <xsl:value-of select="$listbox_height_off"/> 0.25 rotation 1 0 0 -1.57 }
  				  <xsl:call-template name="createLabel">
      <xsl:with-param name="textscale" select="0.5"/>
    </xsl:call-template>
			}
			on Separator {
		     <xsl:call-template name="background_pressed_color"/>
    <xsl:value-of select="$listbox_on"/>
				Transform { translation 0 <xsl:value-of select="$listbox_height_on"/> 0.25 rotation 1 0 0 -1.57 }
				USE __LABEL
			}
			offHl Separator {
				<xsl:call-template name="background_highlight_color"/>
    <xsl:value-of select="$listbox_off_hl"/>
				Transform { translation 0 <xsl:value-of select="$listbox_height_off"/> 0.25 rotation 1 0 0 -1.57 }
				USE __LABEL
			}
			onHl Separator {
				<xsl:call-template name="background_highlight_color"/>
    <xsl:value-of select="$listbox_on_hl"/>
				Transform { translation 0 <xsl:value-of select="$listbox_height_on"/> 0.25 rotation 1 0 0 -1.57 }
				USE __LABEL
			}
		}
	}
	</xsl:template>
  <!-- write out a Material node with diffuseColor from paletteForegroundColor -->
  <xsl:template name="foregroundcolor" match="property[@name='paletteForegroundColor']" mode="foregroundcolor">Material { diffuseColor <xsl:value-of select="color/red div 255"/>
    <xsl:text> </xsl:text>
    <xsl:value-of select="color/green div 255"/>
    <xsl:text> </xsl:text>
    <xsl:value-of select="color/blue div 255"/> }</xsl:template>
  <!-- write out a Material node with diffuseColor from paletteForegroundColor -->
  <xsl:template name="foreground_highlight_color" match="property[@name='paletteForegroundColor']" mode="foreground_highlight_color">Material { diffuseColor <xsl:value-of select="(color/red + 255) div 510"/>
    <xsl:text> </xsl:text>
    <xsl:value-of select="(color/green + 255) div 512"/>
    <xsl:text> </xsl:text>
    <xsl:value-of select="(color/blue + 255) div 512"/> }</xsl:template>
  <!-- write out a Material node with diffuseColor from paletteBackgroundColor -->
  <xsl:template name="backgroundcolor" match="property[@name='paletteBackgroundColor']" mode="backgroundcolor">Material { diffuseColor <xsl:value-of select="color/red div 255"/>
    <xsl:text> </xsl:text>
    <xsl:value-of select="color/green div 255"/>
    <xsl:text> </xsl:text>
    <xsl:value-of select="color/blue div 255"/> }</xsl:template>
  <!-- write out a Material node with diffuseColor to be a more light version of backgroundcolor -->
  <xsl:template name="background_highlight_color">
    <xsl:choose>
      <xsl:when test="property[@name='paletteBackgroundColor']">Material { diffuseColor <xsl:value-of select="(number(property[@name='paletteBackgroundColor']/color/red) + 255) div 510"/>
        <xsl:text> </xsl:text>
        <xsl:value-of select="(number(property[@name='paletteBackgroundColor']/color/green) + 255) div 510"/>
        <xsl:text> </xsl:text>
        <xsl:value-of select="(number(property[@name='paletteBackgroundColor']/color/blue) + 255) div 510"/> }
        </xsl:when>
      <xsl:otherwise>Material { diffuseColor <xsl:value-of select="$highlight_default_color"/> }
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>
  <!-- write out a Material node with diffuseColor to be a more dark version of backgroundcolor -->
  <xsl:template name="background_pressed_color">
    <xsl:choose>
      <xsl:when test="property[@name='paletteBackgroundColor']">Material { diffuseColor <xsl:value-of select="number(property[@name='paletteBackgroundColor']/color/red) div 510"/>
        <xsl:text> </xsl:text>
        <xsl:value-of select="number(property[@name='paletteBackgroundColor']/color/green) div 510"/>
        <xsl:text> </xsl:text>
        <xsl:value-of select="number(property[@name='paletteBackgroundColor']/color/blue) div 510"/> }
        </xsl:when>
      <xsl:otherwise>Material { diffuseColor <xsl:value-of select="$pressed_default_color"/> }
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>
  <!-- will write out a transformation for geometry properties -->
  <!-- for groups this will be done by translating for the upper left corner -->
  <xsl:template match="property[@name='geometry']/rect" mode="group" name="grouptransform">
    <xsl:param name="scalefactor" select="1"/>Transform { translation <xsl:value-of select="x div $scalefactor"/> 0 <xsl:value-of select="y div $scalefactor"/> } </xsl:template>
  <!-- for widgets the translation will be to the center of the widget -->
  <xsl:template match="property[@name='geometry']/rect" mode="widget" name="widgettransform">
    <xsl:param name="scalefactor" select="1"/>Transform { translation <xsl:value-of select="(x + (width div 2 )) div $scalefactor"/> 0 <xsl:value-of select="(y + (height div 2 )) div $scalefactor"/> } </xsl:template>
  <!-- for widgets an inverse translation of the widget one-  the translation will be from the center of the widget -->
  <xsl:template match="property[@name='geometry']/rect" mode="widget_inverse" name="widgettransform_inverse">
    <xsl:param name="scalefactor" select="1"/>Transform { translation <xsl:value-of select="((x + (width div 2 )) div $scalefactor) * -1"/> 0 <xsl:value-of select="((y + (height div 2 )) div $scalefactor) * -1"/> } </xsl:template>
  <!-- for text labels the center is at the bottom of the text label :/ -->
  <xsl:template match="property[@name='geometry']/rect" mode="text" name="texttransform">
    <xsl:param name="scalefactor" select="1"/>Transform { translation <xsl:value-of select="(x + (width div 2 )) div $scalefactor"/> 0 <xsl:value-of select="(y + height) div $scalefactor"/> } </xsl:template>
  <!-- default templates should pass on parameters in the different modes -->
  <xsl:template match="*" mode="default">
    <xsl:param name="scalefactor" select="1"/>
    <xsl:apply-templates mode="default">
      <xsl:with-param name="scalefactor" select="$scalefactor"/>
    </xsl:apply-templates>
  </xsl:template>
  <xsl:template match="*" mode="group">
    <xsl:param name="scalefactor" select="1"/>
    <xsl:apply-templates mode="group">
      <xsl:with-param name="scalefactor" select="$scalefactor"/>
    </xsl:apply-templates>
  </xsl:template>
  <xsl:template match="*" mode="widget">
    <xsl:param name="scalefactor" select="1"/>
    <xsl:apply-templates mode="widget">
      <xsl:with-param name="scalefactor" select="$scalefactor"/>
    </xsl:apply-templates>
  </xsl:template>
  <xsl:template match="*" mode="widget_inverse">
    <xsl:param name="scalefactor" select="1"/>
    <xsl:apply-templates mode="widget_inverse">
      <xsl:with-param name="scalefactor" select="$scalefactor"/>
    </xsl:apply-templates>
  </xsl:template>
  <xsl:template match="*" mode="text">
    <xsl:param name="scalefactor" select="1"/>
    <xsl:apply-templates mode="text">
      <xsl:with-param name="scalefactor" select="$scalefactor"/>
    </xsl:apply-templates>
  </xsl:template>
  <!-- don't write out any text nodes-->
  <xsl:template match="text()"/>
  <xsl:template match="text()" mode="default"/>
  <xsl:template match="text()" mode="group"/>
  <xsl:template match="text()" mode="widget"/>
  <xsl:template match="text()" mode="widget_inverse"/>
  <xsl:template match="text()" mode="text"/>
  <xsl:template match="text()" mode="foregroundcolor"/>
  <xsl:template match="text()" mode="foreground_highlight_color"/>
  <xsl:template match="text()" mode="backgroundcolor"/>
  <!-- templates used just by call-template to perform certain transformations. Having these subroutines, makes it simple to 
       change stuff in one place. -->
  <!-- creates a label with given parameters, call from within the right widget, so that color etc can be derived -->
  <xsl:template name="createLabel">
    <xsl:param name="textscale" select="1"/>
    <xsl:param name="line"/>
    <xsl:param name="name" select="$fontname"/>
    <xsl:param name="justify" select="'CENTER'"/>
    <xsl:param name="defname"/>
    <xsl:param name="connection"/>
    DEF __LABEL SoAbortGroup { abortActions BBOX
      AntiSquish { sizing Y }
      PolygonOffset { units -2 factor -1 }
		 Font { size <xsl:value-of select="$textscale"/>
    <xsl:if test="$name"> name "<xsl:value-of select="$name"/>" </xsl:if> }
   	<xsl:apply-templates mode="foregroundcolor"/>
    <xsl:if test="$defname">DEF <xsl:value-of select="$defname"/>
    </xsl:if> AsciiText { string "<xsl:value-of select="$line"/>" <xsl:if test="$connection and not($testmode)">= USE <xsl:value-of select="$connection"/>
    </xsl:if>  justification <xsl:value-of select="$justify"/> }
	 }
  </xsl:template>
  <!-- goes through a space separated list and create the appropriate texture nodes for the tabTexture list -->
  <xsl:template name="tabTextureNames">
    <xsl:param name="list"/>
    <xsl:param name="head">
      <xsl:choose>
        <xsl:when test="not(substring-before($list,' '))">
          <xsl:value-of select="$list"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:value-of select="substring-before($list,' ')"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:param>
    <xsl:param name="tail" select="substring-after($list,' ')"/>
    <xsl:if test="$head">Texture2 { filename "<xsl:value-of select="$head"/>" }<xsl:if test="$tail">,
        <xsl:call-template name="tabTextureNames">
          <xsl:with-param name="list" select="$tail"/>
        </xsl:call-template>
      </xsl:if>
    </xsl:if>
  </xsl:template>
</xsl:stylesheet>
